updateRinAI(delta) {
  const boss = this.boss;
  if (!boss || !boss.active) return;
  const ai = boss.ai;
  ai.elapsed = (ai.elapsed ?? 0) + delta;
  const now = ai.elapsed;

  if (ai.mode === 1 || ai.mode === 2) {
    if (now >= ai.modeEndsAt) { this.advanceRinMode(); return; }
  }

  // ==== Rin：击杀事件处理（仅第三阶段生效）====
  onEnemyKilledForRin(enemy) {
    if (!this.boss || !this.boss.isBoss || this.boss.bossKind !== "Rin") return;
    const ai = this.boss.ai || {};
    if (ai.mode !== 3) return;
    if (!enemy || enemy.isBoss) return;

    // 每杀死一个“任意单位”额外召唤一个妖精尸体（排除尸体自身，避免递归）
    if (!enemy.isCorpse) {
      const ang = Phaser.Math.Between(0, 359);
      this.spawnRinCorpseAt(enemy.x, enemy.y, ang, BOSS_RIN_CONFIG.corpseRing.speed);
    }

    // 每杀 5 个毛玉 -> 召唤 1 个 basic 妖精
    if ((enemy.enemyType === 'kedama') && !enemy.isCorpse) {
      ai.r3_kedamaKilled = (ai.r3_kedamaKilled || 0) + 1;
      if (ai.r3_kedamaKilled % 5 === 0) {
        const defY = { typeKey: 'yousei', typeConfig: ENEMY_TYPE_CONFIG.yousei, tierKey: ENEMY_RARITIES.BASIC, tierConfig: ENEMY_TYPE_CONFIG.yousei.tiers[ENEMY_RARITIES.BASIC] };
        const posY = this.findEnemySpawnPosition(defY) || { x: enemy.x, y: enemy.y };
        this.spawnEnemyWithEffect(defY, posY);
      }
    }

    // 击杀 basic 妖精 -> 召唤 1 个 basic 阴阳玉（orb）
    if ((enemy.enemyType === 'yousei') && (enemy.enemyTier === ENEMY_RARITIES.BASIC)) {
      const defO = { typeKey: 'orb', typeConfig: ENEMY_TYPE_CONFIG.orb, tierKey: ENEMY_RARITIES.BASIC, tierConfig: ENEMY_TYPE_CONFIG.orb.tiers[ENEMY_RARITIES.BASIC] };
      const posO = this.findEnemySpawnPosition(defO) || { x: enemy.x, y: enemy.y };
      this.spawnEnemyWithEffect(defO, posO);
    }
  }

  switch (ai.mode) {
    case 1: this.updateRinMode1(delta); break;
    case 2: this.updateRinMode2(delta); break;
    case 3: this.updateRinMode3(delta); break;
    default: this.updateRinMode1(delta); break;
  }
}
advanceRinMode() {
  const boss = this.boss; if (!boss || !boss.active) return;
  const ai = boss.ai; const now = this.getBossElapsed();
  this.clearBossBullets();
  boss.body.setVelocity(0, 0);

  if (ai.mode === 1) {
    ai.mode = 2;
    ai.modeEndsAt = now + BOSS_RIN_CONFIG.modeDurations.m2;
    ai.state = "r2_center";
    ai.r2_endAt = ai.modeEndsAt;
    ai.r2_nextFireAt = now;
    ai.r2_phaseDeg = 0;
    boss.invulnerable = false;
    return;
  }
  if (ai.mode === 2) {
    ai.mode = 3;
    ai.modeEndsAt = now + BOSS_RIN_CONFIG.modeDurations.m3; // 由条件结束
    ai.state = "r3_init";
    boss.invulnerable = true;
    return;
  }
  if (ai.mode === 3) {
    ai.mode = 1;
    ai.modeEndsAt = now + BOSS_RIN_CONFIG.modeDurations.m1;
    ai.state = "r1_dash";
    boss.invulnerable = false;
    return;
  }
}
