  spawnBossBullet(opts, magicDamage, withTrail = false) {
    const { key, sizeTiles, judgeTiles, from, dirAngleDeg, forwardSpeed, accel, sideSpeed, owner, percentMaxHpDamage } = opts;
    const b = this.physics.add.image(from.x, from.y, key).setDepth(8);
    b.setActive(true).setVisible(true);
    b.body.setAllowGravity(false);
    this.setDisplaySizeByTiles(b, sizeTiles);
    this.setSpriteCircleHit(b, judgeTiles);
    const rad = Phaser.Math.DegToRad(dirAngleDeg);
    b.ux = Math.cos(rad);
    b.uy = Math.sin(rad);
    b.forwardSpeed = forwardSpeed || 0;
    b.accel = accel || 0;
    b.sideSpeed = sideSpeed || 0;
    b.magicDamage = magicDamage || 0;
    if (Number.isFinite(percentMaxHpDamage) && percentMaxHpDamage > 0) {
      b.percentMaxHpDamage = percentMaxHpDamage;
    }
    // 第十关后：如果子弹来源为 Boss，则乘以 (1 + rank/10)
    if (opts?.owner?.isBoss && Math.floor(this.level || 0) > 10) {
      const rf = Math.max(0, Number.isFinite(this.rank) ? this.rank : 0) / 10;
      const factor = 1 + rf;
      if (factor > 0) b.magicDamage = Math.max(0, Math.round(b.magicDamage * factor));
    }
    if (owner) b.owner = owner;
    this.bossBullets.add(b);
    if (withTrail) {
      // 复用玩家子弹轨迹作为特效
      b.trailTimer = this.time.addEvent({ delay: 60, loop: true, callback: () => {
        if (!b.active) return;
        const t = this.add.image(b.x, b.y, "bullet_trail").setDepth(7).setBlendMode(Phaser.BlendModes.ADD);
        t.setScale(Phaser.Math.FloatBetween(0.2, 0.4)); t.setAlpha(0.6);
        this.tweens.add({ targets: t, alpha: 0, scale: 0, duration: 220, onComplete: () => t.destroy() });
      }});
    }
    
  /* ==== Rin 专属：AI 与工具 ==== */
  initRinAI(boss) {
    boss.ai = {
      elapsed: 0,
      mode: 1,
      modeEndsAt: BOSS_RIN_CONFIG.modeDurations.m1,
      state: "m1_dash_prep",
      nextThink: 0,
      // P1：冲刺序列 0:前 1:右 2:左 3:后
      m1_dashIndex: 0,
      m1_dashUntil: 0,
      m1_pauseUntil: 0,
      m1_dashSpeed: 300,
      m1_dashDuration: 600,
      m1_pauseDuration: 600,
      m1_dashDir: { ux: 1, uy: 0 },
      // P2：环状尸体
      m2_phaseDeg: Phaser.Math.Between(0, 359),
      m2_nextVolleyAt: 0,
      // P3：统计
      m3_started: false,
      m3_kedamaKills: 0,
    };
    boss.invincible = false;
  }

  updateRinAI(delta) {
    const boss = this.boss;
    if (!boss || !boss.active || boss.bossKind !== "Rin") return;
    const ai = boss.ai; ai.elapsed = (ai.elapsed||0) + delta; const now = ai.elapsed;
    if (ai.mode === 1 && now >= ai.modeEndsAt) { this.advanceRinMode(); return; }
    if (ai.mode === 2 && now >= ai.modeEndsAt) { this.advanceRinMode(); return; }
    if (ai.mode === 3) {
      // 若场上无小怪，进入下一阶段（回到P1）
      const mobs = (this.enemies?.getChildren?.()||[]).filter(e=>e && e.active && !e.isBoss);
      if (mobs.length === 0) { this.advanceRinMode(true); return; }
    }
    switch (ai.mode) {
      case 1: this.updateRinMode1(delta); break;
      case 2: this.updateRinMode2(delta); break;
      case 3: this.updateRinMode3(delta); break;
      default: this.updateRinMode1(delta); break;
    }
  }

  advanceRinMode(forceToNext = false) {
    const boss = this.boss; if (!boss) return; const ai = boss.ai; const now = this.getBossElapsed();
    // 清弹并停下
    this.clearBossBullets(); boss.body.setVelocity(0, 0);
    if (ai.mode === 1) {
      ai.mode = 2; ai.modeEndsAt = now + BOSS_RIN_CONFIG.modeDurations.m2; ai.state = "m2_move_center"; return;
    }
    if (ai.mode === 2) {
      ai.mode = 3; ai.modeEndsAt = now + BOSS_RIN_CONFIG.modeDurations.m3; ai.state = "m3_idle"; boss.invincible = true; ai.m3_started = false; return;
    }
    if (ai.mode === 3) {
      ai.mode = 1; ai.modeEndsAt = now + BOSS_RIN_CONFIG.modeDurations.m1; ai.state = "m1_dash_prep"; boss.invincible = false; ai.m1_dashIndex = 0; return;
    }
  }

  updateRinMode1(_delta) {
    const boss = this.boss; const ai = boss.ai; const now = this.getBossElapsed();
    if (ai.state === "m1_dash_prep") {
      // 以自机方向为基准，确定当前 dashIndex 朝向
      const aim = this.aimUnit(boss.x, boss.y, this.player.x, this.player.y);
      let ang = Math.atan2(aim.uy, aim.ux);
      const idx = ai.m1_dashIndex % 4;
      if (idx === 1) ang += Math.PI/2; // 右
      if (idx === 2) ang -= Math.PI/2; // 左
      if (idx === 3) ang += Math.PI;    // 后
      ai.m1_dashDir = { ux: Math.cos(ang), uy: Math.sin(ang) };
      ai.m1_dashUntil = now + ai.m1_dashDuration;
      boss.body.setVelocity(ai.m1_dashDir.ux * ai.m1_dashSpeed, ai.m1_dashDir.uy * ai.m1_dashSpeed);
      ai.state = "m1_dashing";
      return;
    }
    if (ai.state === "m1_dashing") {
      if (now >= ai.m1_dashUntil) {
        boss.body.setVelocity(0, 0);
        // 结束处发一圈针弹
        this.fireRing({
          key: "rin_bullet_needle",
          sizeTiles: BOSS_RIN_CONFIG.hitboxes.bullets.needle.size,
          judgeTiles: BOSS_RIN_CONFIG.hitboxes.bullets.needle.judge,
          count: 15,
          phaseDeg: Phaser.Math.Between(0, 359),
