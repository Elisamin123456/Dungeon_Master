/* ==== BASE CONSTANTS ==== */
import {
  ITEM_TIERS,
  EQUIPMENT_IDS,
  EQUIPMENT_DATA,
} from "./equipmentData.js";

const GAME_WIDTH = 640;
const GAME_HEIGHT = 480;
const MAP_TILES = 64;
const TILE_SIZE = 16;
const WORLD_SIZE = MAP_TILES * TILE_SIZE;
const CAMERA_ZOOM = 2;
const CAMERA_ZOOM_MIN = 1;
const CAMERA_ZOOM_MAX = 3.5;
const CAMERA_ZOOM_STEP = 0.25;

const EQUIPMENT_SLOT_COUNT = 6;
const BASIC_IDS = EQUIPMENT_IDS.basic;
const MID_IDS = EQUIPMENT_IDS.mid;
const LEGENDARY_IDS = EQUIPMENT_IDS.legendary;

const {
  longSword: LONG_SWORD_ID,
  dagger: DAGGER_ID,
  amplifyingTome: AMPLIFYING_TOME_ID,
  brawlersGloves: BRAWLERS_GLOVES_ID,
  rubyCrystal: RUBY_CRYSTAL_ID,
  sapphireCrystal: SAPPHIRE_CRYSTAL_ID,
  bootsOfSpeed: BOOTS_OF_SPEED_ID,
  clothArmor: CLOTH_ARMOR_ID,
  sheen: SHEEN_ID,
} = BASIC_IDS;

const {
  bfSword: BF_SWORD_ID,
  phage: PHAGE_ID,
  noonquiver: NOONQUIVER_ID,
  jingshi: JINGSHI_ID,
  caulfieldsWarhammer: CAULFIELDS_WARHAMMER_ID,
  serratedDirk: SERRATED_DIRK_ID,
  vampiricScepter: VAMPIRIC_SCEPTER_ID,
  tiamat: TIAMAT_ID,
  recurveBow: RECURVE_BOW_ID,
  stinger: STINGER_ID,
  zeal: ZEAL_ID,
  blastingWand: BLASTING_WAND_ID,
  needlesslyLargeRod: NEEDLESSLY_LARGE_ROD_ID,
  aetherWisp: AETHER_WISP_ID,
  fiendishCodex: FIENDISH_CODEX_ID,
  hauntingGuise: HAUNTING_GUISE_ID,
  hextechAlternator: HEXTECH_ALTERNATOR_ID,
  darkSeal: DARK_SEAL_ID,
  cloakOfAgility: CLOAK_OF_AGILITY_ID,
  bamisCinder: BAMIS_CINDER_ID,
  giantsBelt: GIANTS_BELT_ID,
  kindlegem: KINDLEGEM_ID,
  lostChapter: LOST_CHAPTER_ID,
  tearOfTheGoddess: TEAR_OF_THE_GODDESS_ID,
  chainVest: CHAIN_VEST_ID,
  brambleVest: BRAMBLE_VEST_ID,
  wardensMail: WARDENS_MAIL_ID,
} = MID_IDS;

const {
  brokenKingsBlade: BROKEN_KINGS_BLADE_ID,
  witsEnd: WITS_END_ID,
  nashorsTooth: NASHORS_TOOTH_ID,
  guinsosRageblade: GUINSOOS_RAGEBLADE_ID,
  rabadonsDeathcap: RABADONS_DEATHCAP_ID,
  liandrysAnguish: LIANDRYS_ANGUISH_ID,
  infinityOrb: INFINITY_ORB_ID,
  riftmaker: RIFTMAKER_ID,
  soulstealerCodex: SOULSTEALER_CODEX_ID,
  divineSunderer: DIVINE_SUNDERER_ID,
  trinityForce: TRINITY_FORCE_ID,
  lichBane: LICH_BANE_ID,
  manamune: MANAMUNE_ID,
  frostfireGauntlet: FROSTFIRE_GAUNTLET_ID,
  infinityEdge: INFINITY_EDGE_ID,
  navoriQuickblades: NAVORI_QUICKBLADES_ID,
  theCollector: THE_COLLECTOR_ID,
  bloodthirster: BLOODTHIRSTER_ID,
  runaansHurricane: RUNAANS_HURRICANE_ID,
  phantomDancer: PHANTOM_DANCER_ID,
  frozenHeart: FROZEN_HEART_ID,
  thornmail: THORNMAIL_ID,
  heartsteel: HEARTSTEEL_ID,
  titanicHydra: TITANIC_HYDRA_ID,
  sunfireAegis: SUNFIRE_AEGIS_ID,
} = LEGENDARY_IDS;

const EQUIPMENT_BY_TIER = Object.values(EQUIPMENT_DATA).reduce((map, item) => {
  if (!item || !item.tier) return map;
  if (!map[item.tier]) map[item.tier] = [];
  map[item.tier].push(item);
  return map;
}, {});

const EQUIPMENT_TOOLTIP_DEFAULT = "\u67e5\u770b\u9f20\u6807\u79fb\u52a8\u5230\u7684\u4f4d\u7f6e";
const SHOP_ITEMS_PER_REFRESH = 3;
const SHOP_REFRESH_COST = 10;
const SHOP_DEBUG_GOLD = 100000;
const DEBUG_INITIAL_RANK = 100;
const DEBUG_SCENARIO = (() => {
  if (typeof window === "undefined") {
    return false;
  }
  try {
    const params = new URLSearchParams(window.location.search);
    const hash = (window.location.hash || "").toLowerCase();
    return params.has("debug") || hash.includes("debug");
  } catch (error) {
    console.warn("Failed to parse debug flag", error);
    return false;
  }
})();

const DEBUG_BOSS = (() => {
  if (typeof window === "undefined") return false;
  try {
    const params = new URLSearchParams(window.location.search);
    const hash = (window.location.hash || "").toLowerCase();
    return (params.get("debug") === "boss")
      || params.has("boss")
      || params.has("bossDebug")
      || hash.includes("debug-boss")
      || hash.includes("bossdebug");
  } catch (error) {
    console.warn("Failed to parse boss debug flag", error);
    return false;
  }
})();

const DEBUG_SHOP = (() => {
  if (typeof window === "undefined") return false;
  try {
    const params = new URLSearchParams(window.location.search);
    const hash = (window.location.hash || "").toLowerCase();
    return (params.get("debug") === "shop")
      || params.has("shop")
      || params.has("shopDebug")
      || hash.includes("debug-shop")
      || hash.includes("shopdebug");
  } catch (error) {
    console.warn("Failed to parse shop debug flag", error);
    return false;
  }
})();

const BOSS_TEST_CONFIG = {
  id: "Dummy",
  textureKey: "boss_dummy",
  spritePath: "assets/enemy/dummy.png",
  name: "训练假人",
  title: "测试Boss",
  maxHp: 120000,
  armor: 200,
  tiles: 4,
  musicKey: "boss_bgm_dummy",
  musicPath: "music/boss.mp3",
};

/* ==== 新增：Utsuho Boss 配置（灵乌路空｜神之火） ==== */
const BOSS_UTSUHO_CONFIG = {
  id: "Utsuho",
  // 贴图键
  textureIdle: "utsuho_idle",
  textureMoveDown: "utsuho_movedown",
  textureMoveRight: "utsuho_moveright", // 向左时将 flipX=true
  textureDeath: "utsuho_death",
  // 基本信息
  name: "霊烏路　空",
  title: "地獄の人工太陽",
  tiles: 6, // Boss贴图大小：6格
  // 面板与战斗数值
  maxHp: 66666,
  armor: 66,
  contactDamage: 100, // 与 Boss 本体接触伤害（物理）
  bulletMagicDamage: 66, // Boss 弹幕伤害（法术）
  moveSpeed: 100,
  // 冲刺参数
  dashInitSpeed: 6,
  dashAccel: 666, // 速度加速度（单位：像素/秒^2）
  // 采样资源路径
  assets: {
    basePath: "assets/boss/Utsuho/",
    warning: "assets/boss/Utsuho/Nuclearwarning.png", // 提示贴图 16格
    bullets: {
      bigyellow: "assets/boss/Utsuho/bullet/bigyellow.png",
      blue: "assets/boss/Utsuho/bullet/blue.png",
      nuclearbomb: "assets/boss/Utsuho/bullet/nuclearbomb.png",
      nuclearhazard: "assets/boss/Utsuho/bullet/nuclearhazard.png",
      nuclearspawn: "assets/boss/Utsuho/bullet/nuclearspawn.png", // 仅贴图
      yellow: "assets/boss/Utsuho/bullet/yellow.png",
    }
  },
  // BGM（要求：生成后才播放）
  musicKey: "utsuho_bgm",
  musicPath: "music/boss.mp3",
  // 模式时长（毫秒）
  modeDurations: { m1: 41000, m2: 35000, m3: 70000, m4: 35000 },
  // 判定与尺寸（单位：格）
  hitboxes: {
    bullets: {
      bigyellow: { size: 3, judge: 1 },
      blue: { size: 1, judge: 1 },
      nuclearbomb: { size: 16, judge: 10 },
      nuclearhazard: { size: 0.5, judge: 0.5 },
      nuclearspawn: { size: 5, judge: 0 }, // 仅贴图，无判定
      yellow: { size: 3, judge: 1 },
    },
    warningSize: 64
  }
};

/* ==== Boss 注册表：便于其他关卡调用 ==== */
const BOSS_REGISTRY = {
  [BOSS_TEST_CONFIG.id]: BOSS_TEST_CONFIG,
  [BOSS_UTSUHO_CONFIG.id]: BOSS_UTSUHO_CONFIG,
};

/* ==== 装备数据 ==== */
const EQUIPMENT_DATA = {
  [BROKEN_KINGS_BLADE_ID]: {
    id: BROKEN_KINGS_BLADE_ID,
    name: "破败王者之刃",
    icon: "assets/item/legendary/破败王者之刃.png",
    description: [
      "属性",
      "+25 攻击力",
      "+35% 攻击速度",
      "渴血：提供 +10% 物理吸血。",
      "雾之锋：普攻附带攻击特效，相当于目标当前生命值的 7%，对所有单位至少造成 15 点额外伤害，对非boss敌人最多造成 60 点额外伤害，对boss最多造成 300 点额外伤害。",
      "虹吸：在 2 秒内用普攻或技能连续命中同一名敌方单位 3 次时，会造成 30 点魔法伤害，并使目标减速 25%，持续 2 秒，同时自身获得 25% 的移动速度加成，持续同样时间。",
    ],
    stats: {
      attackDamageFlat: 25,
      attackSpeedPct: 0.35,
      physicalLifeSteal: 0.10,
    },
    effects: {
      percentCurrentHp: 0.07,
      percentMinDamage: 15,
      percentMaxDamageNonBoss: 60,
      percentMaxDamageBoss: 300,     // 新增：对boss的最大伤害限制
      tripleHitThreshold: 3,
      tripleHitWindowMs: 2000,
      tripleHitMagicDamage: 30,
      tripleHitSlowPct: 0.25,
      tripleHitSlowMs: 2000,
      selfHastePct: 0.25,
      selfHasteMs: 2000,
    },
  },

  [WITS_END_ID]: {
    id: WITS_END_ID,
    name: "智慧末刃",
    icon: "assets/item/legendary/智慧末刃.png",
    description: [
      "属性",
      "+45 护甲",
      "+45% 攻击速度",
      "被动效果",
      "智慧终结：普攻附带 30 点魔法伤害攻击特效。",
      "当当前生命值低于最大生命值的 50% 时，回复等同于本次攻击特效造成伤害的 100%。",
    ],
    stats: {
      arFlat: 45,
      attackSpeedPct: 0.45,
    },
    effects: {
      witsMagicOnHit: 30,
      witsHealThresholdHpPct: 0.5,
      witsHealPctOfOnHit: 1.0,
    },
  },

  [NASHORS_TOOTH_ID]: {
    id: NASHORS_TOOTH_ID,
    name: "纳什之牙",
    icon: "assets/item/legendary/纳什之牙.png",
    description: [
      "属性",
      "+20 技能急速",
      "+45% 攻击速度",
      "+50 法术强度",
      "被动效果",
      "啃咬：普攻命中时造成 15（+25% 额外攻击力）（+25% 法术强度）的魔法伤害攻击特效。",
    ],
    stats: {
      abilityHaste: 20,
      attackSpeedPct: 0.45,
      abilityPowerFlat: 50,
    },
    effects: {
      nashorBase: 15,
      nashorBonusAdRatio: 0.25,
      nashorApRatio: 0.25,
    },
  },

  [GUINSOOS_RAGEBLADE_ID]: {
    id: GUINSOOS_RAGEBLADE_ID,
    name: "鬼索的狂暴之刃",
    icon: "assets/item/legendary/鬼索的狂暴之刃.png",
    description: [
      "属性",
      "攻击力：35",
      "法术强度：35",
      "攻击速度：25%",
      "被动效果",
      "怨怒：攻击附带30魔法伤害攻击特效。",
      "沸腾打击：普通攻击会提供8%攻击速度，至多4层（32%）。在满层状态下，每第三次攻击会附带2次攻击特效。",
    ],
    stats: {
      attackDamageFlat: 35,
      abilityPowerFlat: 35,
      attackSpeedPct: 0.25,
    },
    effects: {
      ragebladeMagicOnHit: 30,
      ragebladeStackAsPct: 0.08,
      ragebladeMaxStacks: 4,
      ragebladeStackDurationMs: 5000,
      ragebladeExtraProcsAtFull: 2,
      ragebladeExtraProcEvery: 3,
    },
  },
};

/* ==== 回合与数值 ==== */
const ROUND_DURATION = 60000;
const NO_DAMAGE_RANK_INTERVAL = 60000;
const RANK_INITIAL = 10;
const RANK_NO_DAMAGE_MULTIPLIER = 1.5;
const ROUND_CONTINUE_RANK_BONUS = 5;
const PICKUP_ATTRACT_SPEED = 240;

const STAT_UNITS_PER_TILE = 64;
const PIXELS_PER_TILE = TILE_SIZE;
const UNIT_TO_PIXEL = PIXELS_PER_TILE / STAT_UNITS_PER_TILE;
const statUnitsToPixels = (value) => value * UNIT_TO_PIXEL;
const statUnitsToTiles = (value) => value / STAT_UNITS_PER_TILE;

/* ==== 玩家参数 ==== */
const PLAYER_BASE_SPEED = 120;
const PLAYER_FOCUS_MULTIPLIER = 0.35;
const PLAYER_MANA_MAX = 200;
const PLAYER_FOCUS_RADIUS = 2;
const PLAYER_TILE_SCALE = 2;
const PLAYER_ANIMATION_FRAME_RATE = 4;
const PLAYER_HITBOX_RADIUS = PLAYER_FOCUS_RADIUS;

/* ==== 输入绑定 ==== */
const MOVEMENT_KEY_BINDINGS = [
  { code: "W", direction: "up" },
  { code: "S", direction: "down" },
  { code: "A", direction: "left" },
  { code: "D", direction: "right" },
];

/* ==== 字体工具 ==== */
const FONT_SIZE_REGEX = /-?\d+(\.\d+)?/;
const extractFontSizeValue = (value, fallback = 16) => {
  if (typeof value === "number" && Number.isFinite(value)) return value;
  if (typeof value === "string") {
    const m = value.match(FONT_SIZE_REGEX);
    if (m) return Number.parseFloat(m[0]);
  }
  return fallback;
};
const ensureBaseFontSize = (text) => {
  if (!text) return 16;
  const hasDataMethods =
    typeof text.getData === "function" && typeof text.setData === "function";
  if (!hasDataMethods) return extractFontSizeValue(text.style?.fontSize, 16);
  let base = text.getData("baseFontSize");
  if (base == null) {
    base = extractFontSizeValue(text.style?.fontSize, 16);
    text.setData("baseFontSize", base);
  }
  return base;
};
const setFontSizeByScale = (text, scale) => {
  if (!text || typeof text.setFontSize !== "function") return;
  const baseSize = ensureBaseFontSize(text);
  const targetSize = Math.max(1, Math.round(baseSize * scale));
  text.setFontSize(targetSize);
};

/* ==== 武器/弹幕/敌人 ==== */
const WEAPON_ORBIT_RADIUS = 25;
const WEAPON_ORBIT_SPEED = 180; // deg/s
const BULLET_SPEED = 170;
const BULLET_LIFETIME = 4500; // ms

const ENEMY_MAX_COUNT = 40;
const ENEMY_CONTACT_DAMAGE = 45;

/* ==== 玩家基础面板 ==== */
const PLAYER_BASE_STATS = {
  name: "博丽灵梦",
  attackDamage: 50,
  abilityPower: 0,
  attackSpeed: 2,
  maxHp: 1200,
  critChance: 0,
  critDamage: 150,
  defense: 0,
  armor: 0,
  range: 600,
};

/* ==== 预加载场景 ==== */
class PreloadScene extends Phaser.Scene {
  constructor() { super("PreloadScene"); }
  preload() {
    this.load.image("floor", "assets/ground/defultground.png");
    this.load.image("wall", "assets/ground/defultwall.png");
    [
      "reimu_11","reimu_12","reimu_13","reimu_14",
      "reimu_21","reimu_22","reimu_23","reimu_24",
      "reimu_31","reimu_32","reimu_33","reimu_34",
    ].forEach((k)=> this.load.image(k, `assets/player/reimu/${k}.png`));
    this.load.image("weapon", "assets/weapon/yinyangball.png");
    this.load.image("bullet", "assets/bullet/spell.png");
    this.load.image("enemy", "assets/enemy/test_robot.png");
    this.load.image("enemyDeath", "assets/enemy/test_robot_death.png");
    this.load.image("point", "assets/item/point.png");
    this.load.image("itemBrokenKingsBlade", "assets/item/legendary/破败王者之刃.png");
    this.load.image("itemWitsEnd", "assets/item/legendary/智慧末刃.png");
    this.load.image("itemNashorsTooth", "assets/item/legendary/纳什之牙.png");
    this.load.image("itemGuinsoosRageblade", "assets/item/legendary/鬼索的狂暴之刃.png");
    this.load.audio("utsuho_bgm", "music/boss.mp3"); 
    this.load.audio("battle_bgm", "music/battle.mp3");
    this.load.audio("enemycharge", "se/enemycharge.wav");
    this.load.audio("enemyexploded", "se/enemyexploded.wav");
    this.load.audio("itempick", "se/itempick.wav");
    this.load.audio("pause", "se/pause.wav");
    this.load.audio("playershoot", "se/playershoot.wav");
    this.load.audio("pldead", "se/pldead.wav");

    /* 预载 dummy Boss 资源与BGM（保留） */
    this.load.image(BOSS_TEST_CONFIG.textureKey, BOSS_TEST_CONFIG.spritePath);
    this.load.audio(BOSS_TEST_CONFIG.musicKey, BOSS_TEST_CONFIG.musicPath);

    /* ==== 新增：预载 Utsuho 相关资源 ==== */
    // Boss 身体
    this.load.image(BOSS_UTSUHO_CONFIG.textureIdle, `${BOSS_UTSUHO_CONFIG.assets.basePath}Utsuho.png`);
    this.load.image(BOSS_UTSUHO_CONFIG.textureMoveDown, `${BOSS_UTSUHO_CONFIG.assets.basePath}Utsuho_movedown.png`);
    this.load.image(BOSS_UTSUHO_CONFIG.textureMoveRight, `${BOSS_UTSUHO_CONFIG.assets.basePath}Utsuho_moveright.png`);
    this.load.image(BOSS_UTSUHO_CONFIG.textureDeath, `${BOSS_UTSUHO_CONFIG.assets.basePath}Utsuhodeath.png`);
    // 提示框
    this.load.image("utsuho_warning", BOSS_UTSUHO_CONFIG.assets.warning);
    // 弹幕采样
    this.load.image("u_bullet_bigyellow", BOSS_UTSUHO_CONFIG.assets.bullets.bigyellow);
    this.load.image("u_bullet_blue", BOSS_UTSUHO_CONFIG.assets.bullets.blue);
    this.load.image("u_bullet_nuclearbomb", BOSS_UTSUHO_CONFIG.assets.bullets.nuclearbomb);
    this.load.image("u_bullet_nuclearhazard", BOSS_UTSUHO_CONFIG.assets.bullets.nuclearhazard);
    this.load.image("u_bullet_nuclearspawn", BOSS_UTSUHO_CONFIG.assets.bullets.nuclearspawn);
    this.load.image("u_bullet_yellow", BOSS_UTSUHO_CONFIG.assets.bullets.yellow);
    // BGM（生成后播放）
    this.load.audio(BOSS_UTSUHO_CONFIG.musicKey, BOSS_UTSUHO_CONFIG.musicPath);
  }
  create() { this.scene.start("StartScene"); }
}

/* ==== 标题场景 ==== */
class StartScene extends Phaser.Scene {
  constructor() { super("StartScene"); }
  create() {
    const { width, height } = this.scale;
    this.add.rectangle(0, 0, width, height, 0x000000, 0.45).setOrigin(0, 0).setScrollFactor(0);
    const titleText = this.add.text(width/2, height/2-40, "Dungeon Master", {
      fontFamily: '"Zpix", monospace', fontSize: "32px", color: "#ffffff",
    }).setOrigin(0.5);
    ensureBaseFontSize(titleText);
    const promptText = this.add.text(width/2, height/2+20, "点击或按 Enter 开始", {
      fontFamily: '"Zpix", monospace', fontSize: "18px", color: "#d0d0ff",
    }).setOrigin(0.5);
    ensureBaseFontSize(promptText);

    this.input.keyboard.once("keydown-ENTER", ()=> this.scene.start("GameScene"));
    this.input.once("pointerdown", ()=> this.scene.start("GameScene"));
  }
}

/* ==== 游戏场景 ==== */
class GameScene extends Phaser.Scene {
  constructor() {
    super("GameScene");
    this.elapsed = 0;
    this.killCount = 0;
  }

  init() {
    this.debugMode = DEBUG_SCENARIO;
    this.debugBossMode = DEBUG_BOSS;

    this.playerStats = { ...PLAYER_BASE_STATS };
    this.currentHp = this.playerStats.maxHp;
    this.currentMana = PLAYER_MANA_MAX;
    this.attackTimer = null;
    this.spawnTimer = null;
    this.weaponAngle = 0;
    this.rangeVisible = false;
    this.currentZoom = CAMERA_ZOOM;
    this.rank = this.debugMode ? DEBUG_INITIAL_RANK : RANK_INITIAL;
    this.lastDamageTimestamp = 0;
    this.nextNoDamageRankCheck = 0;
    this.roundTimeLeft = ROUND_DURATION;
    this.roundComplete = false;
    this.roundAwaitingDecision = false;
    this.roundOverlayElements = [];
    this.roundOverlayBackground = null;
    this.roundDecisionHandler = null;
    this.playerPoints = 0;
    this.movementDirectionOrder = [];
    this.movementKeyHandlers = [];
    this.bulletTrailGroup = null;
    this.isPaused = false;
    this.pauseOverlayElements = [];
    this.pauseOverlayBackground = null;
    this.pauseDecisionHandler = null;
    this.playerFacing = "down";
    this.playerAnimationKeys = { down: "player-down", left: "player-left", right: "player-left", up: "player-up" };
    this.playerIdleFrames = { down: "reimu_11", left: "reimu_21", right: "reimu_21", up: "reimu_31" };
    this.playerEquipmentSlots = new Array(EQUIPMENT_SLOT_COUNT).fill(null);
    this.playerEquipmentStats = { physicalLifeSteal: 0 };
    this.playerOnHitEffects = [];
    this.playerSpeedBuffMultiplier = 1;
    this.playerSpeedBuffExpiresAt = 0;
    this.draggedEquipmentSlot = null;
    this.equipmentUi = null;
    this.equipmentUiHandlers = [];
    this.activeEquipmentTooltipIndex = null;
    this.sfxConfig = {
      enemycharge: { volume: 0.25 },
      enemyexploded: { volume: 0.325 },
      itempick: { volume: 0.1 },
      pause: { volume: 0.25 },
      playershoot: { volume: 0.4 },
      pldead: { volume: 0.25 },
    };

    // 鬼索叠层相关
    this.guinsooStacks = 0;
    this.guinsooStacksExpireAt = 0;
    this.guinsooFullProcCounter = 0;
    this.hasGuinsoo = false;

    // Boss相关
    this.boss = null;
    this.bossMusic = null;
    this.bossKind = null; // 新增：当前Boss类型ID
    this.bossUi = {
      gfx: null,
      nameText: null,
      titleText: null,
      barX: GAME_WIDTH / 2,
      barY: 34,
      barW: 320,
      barH: 14,
    };

    /* ==== 新增：Boss 弹幕分组 ==== */
    this.bossBullets = null; // Boss子弹（含核弹/黄弹/蓝弹/危害微粒等）
  }

  create() {
    this.setupUIBindings();
    this.initializeEquipmentSystem();
    this.createMap();
    this.createPlayer();
    this.createBulletTrailResources();
    this.createWeapon();
    this.createGroups();
    this.setupCamera();
    this.setupInput();
    this.setupTimers();
    this.setupHUD();
    this.updateStatPanel();
    this.updateResourceBars();

    /* ==== 新增：Boss弹幕分组与碰撞 ==== */
    this.bossBullets = this.physics.add.group();
    // 自机与Boss子弹判定：法术伤害（按Boss配置）
    this.physics.add.overlap(this.player, this.bossBullets, (player, bullet) => {
      if (!bullet.active) return;
      // 仅当标记为Boss弹幕时生效
      const dmg = bullet.magicDamage ?? 0;
      if (dmg > 0) this.applyMagicDamageToPlayer(dmg);
      this.destroyBossBullet(bullet);
    });

    const now = this.time.now;
    this.lastDamageTimestamp = now;
    this.nextNoDamageRankCheck = now + NO_DAMAGE_RANK_INTERVAL;
    this.roundTimeLeft = ROUND_DURATION;
    this.roundComplete = false;
    this.roundAwaitingDecision = false;
    this.updateOverlayScale();
    this.updateHUD();

    if (!this.battleBgm) {
      this.battleBgm = this.sound.add("battle_bgm", { loop: true, volume: 0.6 });
      this.battleBgm.play();
      this.events.once("shutdown", () => { if (this.battleBgm?.isPlaying) this.battleBgm.stop(); });
      this.events.once("destroy", () => { if (this.battleBgm) { this.battleBgm.stop(); this.battleBgm.destroy(); this.battleBgm = null; } });
    } else if (!this.battleBgm.isPlaying) {
      this.battleBgm.play();
    }

    // Debug Boss 模式：停止一切音乐 -> 生成Utsuho -> 再播放Boss曲
    if (this.debugBossMode) {
      try { this.sound.stopAll(); } catch (_) {}
      if (this.spawnTimer) { this.spawnTimer.remove(); this.spawnTimer = null; }

      // 生成于场地中上方
      this.spawnBossById("Utsuho", { x: WORLD_SIZE/2, y: Math.floor(WORLD_SIZE * 0.25) });

      // 生成后才播放 Boss 音乐
      this.bossMusic = this.sound.add(BOSS_UTSUHO_CONFIG.musicKey, { loop: true, volume: 1.5 });
      this.bossMusic.play();

      // 退出或销毁场景时清理
      this.events.once("shutdown", () => {
        this.clearBossUI();
        if (this.bossMusic) { this.bossMusic.stop(); this.bossMusic.destroy(); this.bossMusic = null; }
      });
      this.events.once("destroy", () => {
        this.clearBossUI();
        if (this.bossMusic) { this.bossMusic.stop(); this.bossMusic.destroy(); this.bossMusic = null; }
      });
    }
  }

  /* ==== UI 绑定 ==== */
  setupUIBindings() {
    this.ui = {
      hpBar: document.getElementById("hp-bar"),
      hpLabel: document.getElementById("hp-bar-label"),
      mpBar: document.getElementById("mp-bar"),
      mpLabel: document.getElementById("mp-bar-label"),
      statContainer: document.getElementById("stat-lines"),
      skillOverlay: document.getElementById("skill-space-overlay"),
      skillTimer: document.getElementById("skill-space-timer"),
      timerValue: document.getElementById("sidebar-timer-value"),
      killValue: document.getElementById("sidebar-kill-value"),
      rankValue: document.getElementById("sidebar-rank-value"),
      pointValue: document.getElementById("sidebar-point-value"),
      equipmentDetails: document.getElementById("sidebar-equipment-details"),
      bossHeader: document.getElementById("boss-header"),
      bossName: document.getElementById("boss-name"),
      bossTitle: document.getElementById("boss-title")
    };
  }
  showBossHeader(name, title) {
      if (!this.ui.bossHeader || !this.ui.bossName || !this.ui.bossTitle) return;
      this.ui.bossName.textContent = name || "";
      this.ui.bossTitle.textContent = title || "";
      this.ui.bossHeader.style.display = "block";
  }

  clearBossHeader() {
      if (!this.ui.bossHeader) return;
      this.ui.bossHeader.style.display = "none";
      if (this.ui.bossName) this.ui.bossName.textContent = "";
      if (this.ui.bossTitle) this.ui.bossTitle.textContent = "";
  }
  /* ==== 装备系统 ==== */
  initializeEquipmentSystem() {
    if (this.equipmentUiHandlers && this.equipmentUiHandlers.length > 0) {
      this.teardownEquipmentSystem();
    }
    const slotElements = Array.from(
      document.querySelectorAll(".equipment-slot[data-slot-index]")
    );
    const previewElement = document.getElementById("equipment-slot-1-preview");
    const previewImage = document.getElementById("equipment-slot-1-preview-img");

    this.equipmentUi = {
      slots: slotElements.map((element) => ({
        element,
        icon: element.querySelector(".equipment-icon"),
      })),
      previewElement,
      previewImage,
    };
    this.bindPreviewRepositionEvents();
    this.events.once("shutdown", () => this.unbindPreviewRepositionEvents());
    this.events.once("destroy", () => this.unbindPreviewRepositionEvents());

    this.equipmentUiHandlers = [];

    slotElements.forEach((element) => {
      const handlers = {
        dragstart: (event) => this.handleEquipmentDragStart(event),
        dragenter: (event) => this.handleEquipmentDragEnter(event),
        dragover: (event) => this.handleEquipmentDragOver(event),
        dragleave: (event) => this.handleEquipmentDragLeave(event),
        drop: (event) => this.handleEquipmentDrop(event),
        dragend: (event) => this.handleEquipmentDragEnd(event),
        mouseenter: (event) => this.handleEquipmentSlotEnter(event),
        mouseleave: () => this.handleEquipmentSlotLeave(),
      };
      Object.entries(handlers).forEach(([type, handler]) => {
        this.registerEquipmentUiHandler(element, type, handler);
      });
    });

    this.refreshEquipmentUI();
    this.refreshEquipmentTooltip(null);

    if (this.debugMode || this.debugBossMode) {
      this.equipItem(0, BROKEN_KINGS_BLADE_ID);
      this.equipItem(1, WITS_END_ID);
      this.equipItem(2, NASHORS_TOOTH_ID);
      this.equipItem(3, GUINSOOS_RAGEBLADE_ID);
    } else {
      this.recalculateEquipmentEffects();
    }

    this.events.once("shutdown", () => this.teardownEquipmentSystem());
    this.events.once("destroy", () => this.teardownEquipmentSystem());
  }

  registerEquipmentUiHandler(element, type, handler) {
    if (!element || typeof element.addEventListener !== "function") return;
    element.addEventListener(type, handler);
    this.equipmentUiHandlers.push({ element, type, handler });
  }

  teardownEquipmentSystem() {
    this.unbindPreviewRepositionEvents();
    if (this.equipmentUiHandlers) {
      this.equipmentUiHandlers.forEach(({ element, type, handler }) => {
        if (element?.removeEventListener) element.removeEventListener(type, handler);
      });
      this.equipmentUiHandlers = [];
    }
    this.equipmentUi = null;
    this.draggedEquipmentSlot = null;
    this.activeEquipmentTooltipIndex = null;
  }

  getEquipmentDefinition(itemId) {
    if (!itemId) return null;
    return EQUIPMENT_DATA[itemId] ?? null;
  }

  refreshEquipmentUI() {
    if (!this.equipmentUi?.slots) return;
    this.equipmentUi.slots.forEach(({ element, icon }, index) => {
      const itemId = this.playerEquipmentSlots[index];
      const item = this.getEquipmentDefinition(itemId);
      if (item && icon) {
        icon.src = item.icon;
        icon.alt = item.name;
        element.classList.add("has-item");
        element.setAttribute("draggable", "true");
      } else {
        if (icon) {
          icon.removeAttribute("src");
          icon.alt = "";
        }
        element.classList.remove("has-item");
        element.removeAttribute("draggable");
        element.classList.remove("dragging");
        element.classList.remove("drag-over");
      }
    });

    const previewElement = this.equipmentUi.previewElement;
    const previewImage = this.equipmentUi.previewImage;
    const previewItem = this.getEquipmentDefinition(this.playerEquipmentSlots[0]);

    if (previewElement && previewImage) {
      if (previewItem) {
        previewElement.classList.add("active");
        previewImage.src = previewItem.icon;
        previewImage.alt = previewItem.name;
        this.positionPreviewUnderSlot1();
      } else {
        previewElement.classList.remove("active");
        previewElement.style.background = "transparent";
        previewElement.style.backgroundImage = "none";
        previewImage.removeAttribute("src");
        previewImage.alt = "";
      }
    }

  }

  refreshEquipmentTooltip(slotIndex = null) {
    if (!this.ui?.equipmentDetails) return;
    const container = this.ui.equipmentDetails;
    container.innerHTML = "";

    const itemId = slotIndex == null ? null : this.playerEquipmentSlots[slotIndex];
    const item = this.getEquipmentDefinition(itemId);
    if (!item) {
      const hint = document.createElement("span");
      hint.className = "sidebar-equipment-hint";
      hint.textContent = EQUIPMENT_TOOLTIP_DEFAULT;
      container.appendChild(hint);
      return;
    }

    const title = document.createElement("span");
    title.className = "sidebar-equipment-title";
    title.textContent = item.name;
    container.appendChild(title);
    (item.description || []).forEach((line) => {
      const row = document.createElement("span");
      row.textContent = line;
      container.appendChild(row);
    });
  }

  equipItem(slotIndex, itemId) {
    if (slotIndex < 0 || slotIndex >= this.playerEquipmentSlots.length) return;
    this.playerEquipmentSlots[slotIndex] = itemId ?? null;
    this.refreshEquipmentUI();
    this.recalculateEquipmentEffects();
    const tooltipIndex = this.activeEquipmentTooltipIndex ?? null;
    this.refreshEquipmentTooltip(tooltipIndex);
  }

  swapEquipmentSlots(sourceIndex, targetIndex) {
    if (
      sourceIndex == null || targetIndex == null ||
      sourceIndex === targetIndex ||
      Number.isNaN(sourceIndex) || Number.isNaN(targetIndex)
    ) return;
    const slots = this.playerEquipmentSlots;
    const tmp = slots[sourceIndex];
    slots[sourceIndex] = slots[targetIndex];
    slots[targetIndex] = tmp;
    this.refreshEquipmentUI();
    this.recalculateEquipmentEffects();
    const tooltipIndex = this.activeEquipmentTooltipIndex ?? null;
    this.refreshEquipmentTooltip(tooltipIndex);
  }

  recalculateEquipmentEffects() {
    this.playerEquipmentStats = { physicalLifeSteal: 0 };
    this.playerOnHitEffects = [];

    const base = { ...PLAYER_BASE_STATS };
    let addAD = 0, addASPct = 0, addAP = 0, addAR = 0, addDEF = 0;
    let abilityHaste = 0;
    let hasGuinsoo = false;

    const appliedUniques = new Set();
    for (let i = 0; i < this.playerEquipmentSlots.length; i += 1) {
      const itemId = this.playerEquipmentSlots[i];
      const item = this.getEquipmentDefinition(itemId);
      if (!item) continue;

      if (item.stats?.attackDamageFlat) addAD += item.stats.attackDamageFlat;
      if (item.stats?.attackSpeedPct) addASPct += item.stats.attackSpeedPct;
      if (item.stats?.physicalLifeSteal) this.playerEquipmentStats.physicalLifeSteal += item.stats.physicalLifeSteal;

      if (item.stats?.abilityPowerFlat) addAP += item.stats.abilityPowerFlat;
      if (item.stats?.arFlat) addAR += item.stats.arFlat;
      if (item.stats?.defFlat) addDEF += item.stats.defFlat;
      if (item.stats?.abilityHaste) abilityHaste += item.stats.abilityHaste;

      if (item.id === BROKEN_KINGS_BLADE_ID && !appliedUniques.has(item.id)) {
        this.playerOnHitEffects.push((context) => this.handleBrokenKingsBladeOnHit(context));
        appliedUniques.add(item.id);
      }
      if (item.id === GUINSOOS_RAGEBLADE_ID) hasGuinsoo = true;
    }

    base.attackDamage = Math.max(1, Math.round(base.attackDamage + addAD));
    base.attackSpeed = Math.max(0.1, Number((base.attackSpeed * (1 + addASPct)).toFixed(3)));
    base.abilityPower = Math.max(0, Math.round((base.abilityPower ?? 0) + addAP));
    base.armor = Math.max(0, Math.round((base.armor ?? 0) + addAR));
    base.defense = Math.max(0, Math.round((base.defense ?? 0) + addDEF));
    base.abilityHaste = abilityHaste;
    this.playerStats = base;

    this.hasGuinsoo = hasGuinsoo;
    if (!this.hasGuinsoo) {
      this.guinsooStacks = 0;
      this.guinsooStacksExpireAt = 0;
      this.guinsooFullProcCounter = 0;
    }

    this.rebuildAttackTimer();
    this.updateStatPanel();
  }

  getAttackSpeedBonusMultiplier() {
    const data = EQUIPMENT_DATA[GUINSOOS_RAGEBLADE_ID]?.effects;
    if (!this.hasGuinsoo || !data) return 1;
    const stacks = Math.min(this.guinsooStacks || 0, data.ragebladeMaxStacks || 0);
    return 1 + stacks * (data.ragebladeStackAsPct || 0);
  }

  rebuildAttackTimer() {
    if (this.attackTimer) {
      this.attackTimer.remove();
      this.attackTimer = null;
    }
    const effAS = this.playerStats.attackSpeed * this.getAttackSpeedBonusMultiplier();
    const attackDelay = 1000 / Math.max(0.1, effAS);
    this.attackTimer = this.time.addEvent({
      delay: attackDelay,
      loop: true,
      callback: () => this.tryFireBullet(),
    });
  }

  /* ==== 地图 ==== */
  createMap() {
    this.physics.world.setBounds(0, 0, WORLD_SIZE, WORLD_SIZE);
    this.floor = this.add.tileSprite(WORLD_SIZE/2, WORLD_SIZE/2, WORLD_SIZE, WORLD_SIZE, "floor").setOrigin(0.5);
    this.wallGroup = this.physics.add.staticGroup();
    this.generateRandomSegmentsMap();
  }

  generateRandomSegmentsMap() {
    if (this.wallGroup) this.wallGroup.clear(true, true);
    // debug 场景不生成墙
    // ✅ Boss 房间：只保留边框，中央不放墙
    const halfTile = TILE_SIZE / 2;
    const width = MAP_TILES;
    const height = MAP_TILES;
    const isWall = Array.from({ length: height }, () => Array(width).fill(false));
    const inBounds = (x, y) => x >= 0 && y >= 0 && x < width && y < height;
    const startX = Math.floor(width / 2);
    const startY = Math.floor(height / 2);
    let wallCount = 0;
    const markWall = (x, y, v) => {
      if (!inBounds(x, y)) return;
      if (isWall[y][x] === v) return;
      isWall[y][x] = v; wallCount += v ? 1 : -1;
    };

    // 先标记四周边框
    for (let x = 0; x < width; x += 1) { markWall(x, 0, true); markWall(x, height-1, true); }
    for (let y = 1; y < height-1; y += 1) { markWall(0, y, true); markWall(width-1, y, true); }

    // ✅ 仅 Boss 房间：渲染边框后直接返回（不在中间生成任何墙）
    if (this.debugBossMode) {
      for (let y=0;y<height;y+=1) {
        for (let x=0;x<width;x+=1) {
          if (isWall[y][x]) {
            const wx = x * TILE_SIZE + halfTile;
            const wy = y * TILE_SIZE + halfTile;
            this.addWall(wx, wy);
          }
        }
      }
      return; // ← 关键：中间不放墙
    }
    const isConnected = () => {
      if (isWall[startY][startX]) return false;
      const totalFloor = width * height - wallCount;
      const visited = Array.from({ length: height }, () => Array(width).fill(false));
      const q = [{ x: startX, y: startY }];
      visited[startY][startX] = true;
      let read = 0, reach = 1;
      while (read < q.length) {
        const { x, y } = q[read++ ];
        const neigh = [ {nx:x+1,ny:y}, {nx:x-1,ny:y}, {nx:x,ny:y+1}, {nx:x,ny:y-1} ];
        for (let i=0;i<neigh.length;i+=1) {
          const { nx, ny } = neigh[i];
          if (!inBounds(nx, ny) || visited[ny][nx] || isWall[ny][nx]) continue;
          visited[ny][nx] = true; reach += 1; q.push({x:nx,y:ny});
        }
      }
      return reach === totalFloor;
    };

    const blockedRadius = 3;
    for (let dy=-blockedRadius; dy<=blockedRadius; dy+=1) {
      for (let dx=-blockedRadius; dx<=blockedRadius; dx+=1) {
        markWall(
          Phaser.Math.Clamp(startX + dx, 1, width - 2),
          Phaser.Math.Clamp(startY + dy, 1, height - 2),
          false
        );
      }
    }

    const trySegment = (tiles) => {
      for (let i=0;i<tiles.length;i+=1) {
        const { x, y } = tiles[i];
        if (!inBounds(x, y) || isWall[y][x]) return false;
        if (Math.abs(x - startX) <= blockedRadius && Math.abs(y - startY) <= blockedRadius) return false;
      }
      tiles.forEach(({x,y})=> markWall(x, y, true));
      if (!isConnected()) { tiles.forEach(({x,y})=> markWall(x, y, false)); return false; }
      return true;
    };

    const placeSegments = (count, vertical) => {
      let placed = 0, attempts = 0;
      while (placed < count && attempts < count * 200) {
        attempts += 1;
        const length = 10;
        const sx = Phaser.Math.Between(1, vertical ? width - 2 : width - length - 1);
        const sy = Phaser.Math.Between(1, vertical ? height - length - 1 : height - 2);
        const tiles = [];
        for (let i=0;i<length;i+=1) {
          const x = sx + (vertical ? 0 : i);
          const y = sy + (vertical ? i : 0);
          tiles.push({ x, y });
        }
        if (trySegment(tiles)) placed += 1;
      }
    };

    placeSegments(25, false);
    placeSegments(25, true);

    for (let y=0;y<height;y+=1) {
      for (let x=0;x<width;x+=1) {
        if (isWall[y][x]) {
          const wx = x * TILE_SIZE + halfTile;
          const wy = y * TILE_SIZE + halfTile;
          this.addWall(wx, wy);
        }
      }
    }
  }

  addWall(x, y, scale = 1) {
    const wall = this.wallGroup.create(x, y, "wall");
    wall.setOrigin(0.5);
    wall.setScale(scale);
    wall.refreshBody();
    return wall;
  }

  /* ==== 玩家与动画 ==== */
  createPlayer() {
    this.player = this.physics.add
      .sprite(WORLD_SIZE/2, WORLD_SIZE/2, this.playerIdleFrames.down)
      .setDepth(10);
    this.player.body.setAllowGravity(false);
    this.player.setCollideWorldBounds(true);
    this.applyPlayerScale();
    if (typeof this.player.setRoundPixels === "function") this.player.setRoundPixels(true);
    this.createPlayerAnimations();
    this.stopPlayerAnimation(this.playerFacing);

    this.focusIndicator = this.add.circle(this.player.x, this.player.y, PLAYER_FOCUS_RADIUS, 0xff6677, 0.9)
      .setDepth(11).setVisible(false);

    this.rangeGraphics = this.add.graphics().setDepth(2);
    this.rangeGraphics.clear();

    this.physics.add.collider(this.player, this.wallGroup);
  }

  configurePlayerHitbox() {
    if (!this.player || !this.player.body) return;
    const frameWidth = this.player.width || 1;
    const frameHeight = this.player.height || 1;
    const scaleX = frameWidth !== 0 ? this.player.displayWidth / frameWidth : 1;
    const scaleY = frameHeight !== 0 ? this.player.displayHeight / frameHeight : 1;
    const averageScale = (scaleX && scaleY) ? (scaleX + scaleY) / 2 : 1;
    const radius = averageScale !== 0 ? PLAYER_HITBOX_RADIUS / averageScale : PLAYER_HITBOX_RADIUS;
    const offsetX = frameWidth / 2 - radius;
    const offsetY = frameHeight / 2 - radius;
    this.player.body.setCircle(radius, offsetX, offsetY);
  }

  applyPlayerScale() {
    if (!this.player) return;
    const frame = this.player.frame;
    const frameWidth = frame?.width ?? this.player.width ?? PIXELS_PER_TILE;
    const frameHeight = frame?.height ?? this.player.height ?? PIXELS_PER_TILE;
    const maxDimension = Math.max(frameWidth, frameHeight);
    const targetSize = PIXELS_PER_TILE * PLAYER_TILE_SCALE;
    const scale = maxDimension > 0
      ? (PIXELS_PER_TILE * PLAYER_TILE_SCALE) / maxDimension
      : PLAYER_TILE_SCALE;
    const currentScale = this.player.scaleX ?? 1;
    if (Math.abs(currentScale - scale) > 0.0001) this.player.setScale(scale);
    this.configurePlayerHitbox();
  }

  registerMovementDirection(direction) {
    if (!direction) return;
    const order = this.movementDirectionOrder ?? [];
    const index = order.indexOf(direction);
    if (index !== -1) order.splice(index, 1);
    order.push(direction);
    this.movementDirectionOrder = order;
  }
  unregisterMovementDirection(direction) {
    if (!direction || !this.movementDirectionOrder) return;
    const idx = this.movementDirectionOrder.indexOf(direction);
    if (idx !== -1) this.movementDirectionOrder.splice(idx, 1);
  }
  isMovementDirectionActive(direction) {
    if (!direction || !this.keys) return false;
    const key = this.keys[direction];
    return Boolean(key && key.isDown);
  }
  resolveMovementDirection(inputVX, inputVY) {
    if (this.movementDirectionOrder && this.movementDirectionOrder.length > 0) {
      for (let i = this.movementDirectionOrder.length - 1; i >= 0; i -= 1) {
        const dir = this.movementDirectionOrder[i];
        if (this.isMovementDirectionActive(dir)) return dir;
      }
    }
    if (Math.abs(inputVX) > Math.abs(inputVY)) return inputVX > 0 ? "right" : "left";
    if (inputVY !== 0) return inputVY > 0 ? "down" : "up";
    if (inputVX !== 0) return inputVX > 0 ? "right" : "left";
    return this.playerFacing ?? "down";
  }

  createPlayerAnimations() {
    [
      { key: "player-down", frames: ["reimu_11","reimu_12","reimu_13","reimu_14"] },
      { key: "player-left", frames: ["reimu_21","reimu_22","reimu_23","reimu_24"] },
      { key: "player-up",   frames: ["reimu_31","reimu_32","reimu_33","reimu_34"] },
    ].forEach(({ key, frames }) => {
      if (this.anims.exists(key)) return;
      this.anims.create({ key, frames: frames.map((f)=>({key:f})), frameRate: PLAYER_ANIMATION_FRAME_RATE, repeat: -1 });
    });
  }

  playPlayerAnimation(direction) {
    if (!this.player) return;
    const animKey = this.playerAnimationKeys[direction];
    if (!animKey) return;
    const shouldFlip = direction === "right";
    this.player.setFlipX(shouldFlip);
    if (this.player.anims.currentAnim?.key !== animKey || !this.player.anims.isPlaying) {
      this.player.anims.play(animKey, true);
    }
    this.applyPlayerScale();
  }
  stopPlayerAnimation(direction) {
    if (!this.player) return;
    const idleKey = this.playerIdleFrames[direction] ?? this.playerIdleFrames.down;
    const shouldFlip = direction === "right";
    if (this.player.flipX !== shouldFlip) this.player.setFlipX(shouldFlip);
    if (this.player.anims.isPlaying) this.player.anims.stop();
    if (idleKey && this.player.texture?.key !== idleKey) this.player.setTexture(idleKey);
    this.applyPlayerScale();
  }
  updatePlayerAnimationState(isMoving, inputVX, inputVY) {
    if (!this.player) return;
    let nextDir = this.playerFacing ?? "down";
    if (isMoving) {
      nextDir = this.resolveMovementDirection(inputVX, inputVY);
      this.playPlayerAnimation(nextDir);
    } else {
      this.stopPlayerAnimation(nextDir);
    }
    this.playerFacing = nextDir;
  }

  /* ==== 武器与弹轨 ==== */
  createWeapon() {
    this.weaponSprite = this.add.sprite(this.player.x + WEAPON_ORBIT_RADIUS, this.player.y, "weapon").setDepth(9);
    const weaponSize = PIXELS_PER_TILE;
    this.weaponSprite.setDisplaySize(weaponSize, weaponSize);
    if (typeof this.weaponSprite.setRoundPixels === "function") this.weaponSprite.setRoundPixels(true);
  }
  createBulletTrailResources() {
    if (!this.textures.exists("bullet_trail")) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      g.fillStyle(0xffffff, 1); g.fillCircle(5, 5, 5);
      g.generateTexture("bullet_trail", 10, 10); g.destroy();
    }
    if (!this.textures.exists("dash_particle")) { // 新增：冲刺微粒
      const g2 = this.make.graphics({ x: 0, y: 0, add: false });
      g2.fillStyle(0xffaa00, 1); g2.fillCircle(3, 3, 3);
      g2.generateTexture("dash_particle", 6, 6); g2.destroy();
    }
    this.destroyBulletTrailGroup();
    this.bulletTrailGroup = this.add.group();
    this.events.once("shutdown", () => this.destroyBulletTrailGroup());
    this.events.once("destroy", () => this.destroyBulletTrailGroup());
  }
  destroyBulletTrailGroup() {
    if (this.bulletTrailGroup) {
      this.bulletTrailGroup.getChildren().forEach((trail) => trail.destroy());
      this.bulletTrailGroup.clear(true, true);
      this.bulletTrailGroup = null;
    }
  }
  attachBulletTrailToBullet(bullet) {
    if (!bullet || !this.bulletTrailGroup) return;
    if (bullet.trailTimer) bullet.trailTimer.remove(false);
    bullet.trailTimer = this.time.addEvent({ delay: 45, loop: true, callback: () => this.spawnBulletTrail(bullet) });
    this.spawnBulletTrail(bullet);
  }
  detachBulletTrailFromBullet(bullet, burst = false) {
    if (!bullet) return;
    if (bullet.trailTimer) { bullet.trailTimer.remove(false); bullet.trailTimer = null; }
    if (burst) this.spawnBulletTrail(bullet, 3);
  }
  spawnBulletTrail(bullet, quantity = 1) {
    if (!this.bulletTrailGroup || !bullet || !bullet.active) return;
    for (let i=0;i<quantity;i+=1) {
      let trail = this.bulletTrailGroup.getFirstDead(false);
      if (!trail) {
        trail = this.add.image(0, 0, "bullet_trail");
        trail.setDepth(7); trail.setBlendMode(Phaser.BlendModes.ADD);
        trail.setActive(false); trail.setVisible(false);
        this.bulletTrailGroup.add(trail);
      }
      if (!trail) return;
      trail.setActive(true); trail.setVisible(true);
      trail.x = bullet.x; trail.y = bullet.y;
      const baseScale = 0.4; const randomScale = Phaser.Math.FloatBetween(0.2, 0.5);
      trail.setScale(baseScale + randomScale); trail.setAlpha(0.6);
      this.tweens.add({
        targets: trail, alpha: 0, scale: 0, duration: 220, onComplete: () => {
          trail.setActive(false); trail.setVisible(false);
        }
      });
    }
  }

  /* ==== 物理组与碰撞 ==== */
  createGroups() {
    this.enemies = this.physics.add.group();
    this.bullets = this.physics.add.group();
    this.loot = this.physics.add.group();

    this.physics.add.collider(this.enemies, this.wallGroup);
    this.physics.add.collider(this.enemies, this.enemies);

    this.physics.add.overlap(this.bullets, this.enemies, this.handleBulletEnemyOverlap, null, this);
    this.physics.add.overlap(this.player, this.enemies, this.handlePlayerEnemyContact, null, this);
    this.physics.add.overlap(this.player, this.loot, this.collectPoint, null, this);
  }

  /* ==== 相机 ==== */
  setupCamera() {
    const camera = this.cameras.main;
    camera.setBounds(0, 0, WORLD_SIZE, WORLD_SIZE);
    camera.startFollow(this.player, false, 1, 1);
    camera.setZoom(this.currentZoom);
    camera.roundPixels = false;
  }
  handleMouseWheel(_pointer, _gameObjects, _deltaX, deltaY) {
    if (!deltaY) return;
    const direction = Math.sign(deltaY);
    if (direction === 0) return;
    this.currentZoom = Phaser.Math.Clamp(this.currentZoom - direction * CAMERA_ZOOM_STEP, CAMERA_ZOOM_MIN, CAMERA_ZOOM_MAX);
    this.cameras.main.setZoom(this.currentZoom);
    this.updateOverlayScale();
  }
  updateOverlayScale() {
    const overlayScale = CAMERA_ZOOM / this.currentZoom;
    this.scaleOverlayElement(this.roundOverlayBackground, overlayScale);
    this.scaleOverlayElement(this.roundOverlayElements, overlayScale);
    this.scaleOverlayElement(this.pauseOverlayBackground, overlayScale);
    this.scaleOverlayElement(this.pauseOverlayElements, overlayScale);
  }
  scaleOverlayElement(target, scale) {
    if (!target) return;
    if (Array.isArray(target)) { target.forEach((t)=> this.scaleOverlayElement(t, scale)); return; }
    if (target instanceof Phaser.GameObjects.Text) setFontSizeByScale(target, scale);
    else if (typeof target.setScale === "function") target.setScale(scale);
  }

  /* ==== 声音与暂停 ==== */
  playSfx(key, overrides = {}) {
    if (!this.sound) return;
    const baseConfig = this.sfxConfig?.[key] ?? {};
    this.sound.play(key, { ...baseConfig, ...overrides });
  }
  handlePauseKey(event) {
    if (!event || event.code !== "Escape") return;
    if (event.repeat) { event.preventDefault(); return; }
    if (this.roundAwaitingDecision || (this.roundComplete && !this.isPaused)) return;
    event.preventDefault();
    if (this.isPaused) this.resumeGame();
    else this.pauseGame();
  }
  pauseGame() {
    if (this.isPaused || this.roundComplete || this.roundAwaitingDecision) return;
    this.isPaused = true;
    this.physics.pause();
    this.time.timeScale = 0;
    if (this.battleBgm?.isPlaying) this.battleBgm.pause();
    if (this.attackTimer) this.attackTimer.paused = true;
    if (this.spawnTimer) this.spawnTimer.paused = true;
    this.showPauseOverlay();
    this.playSfx("pause");
  }
  resumeGame() {
    if (!this.isPaused) return;
    this.isPaused = false;
       this.time.timeScale = 1;
    this.physics.resume();
    if (this.battleBgm) {
      if (this.battleBgm.isPaused) this.battleBgm.resume();
      else if (!this.battleBgm.isPlaying) this.battleBgm.play();
    }
    if (this.attackTimer) this.attackTimer.paused = false;
    if (this.spawnTimer) this.spawnTimer.paused = false;
    this.clearPauseOverlay();
  }
  exitToStartFromPause() {
    if (!this.isPaused) return;
    this.clearPauseOverlay();
    this.isPaused = false;
    this.time.timeScale = 1;
    this.physics.resume();
    if (this.battleBgm) {
      if (this.battleBgm.isPaused) this.battleBgm.resume();
      else if (!this.battleBgm.isPlaying) this.battleBgm.play();
    }
    if (this.attackTimer) this.attackTimer.paused = false;
    if (this.spawnTimer) this.spawnTimer.paused = false;
    this.scene.start("StartScene");
  }
  showPauseOverlay() {
    this.clearPauseOverlay();
    const bg = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.6)
      .setScrollFactor(0).setDepth(45);
    const title = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 - 24, "游戏暂停", {
      fontFamily: '"Zpix", monospace', fontSize: "18px", color: "#ffffff",
    }).setOrigin(0.5).setScrollFactor(0).setDepth(46);
    ensureBaseFontSize(title);
    const prompt = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 14, "按 ESC 或 Y 继续游戏，按 N 返回标题", {
      fontFamily: '"Zpix", monospace', fontSize: "14px", color: "#d0d0ff",
    }).setOrigin(0.5).setScrollFactor(0).setDepth(46);
    ensureBaseFontSize(prompt);

    this.pauseOverlayBackground = bg;
    this.pauseOverlayElements = [title, prompt];
    this.updateOverlayScale();

    this.pauseDecisionHandler = (e) => {
      if (!e) return;
      if (e.code === "KeyY" || e.code === "Enter" || e.code === "Escape") this.resumeGame();
      else if (e.code === "KeyN") this.exitToStartFromPause();
    };
    this.input.keyboard.on("keydown", this.pauseDecisionHandler, this);
  }
  clearPauseOverlay() {
    if (this.pauseOverlayElements?.length) this.pauseOverlayElements.forEach((el)=> el.destroy());
    this.pauseOverlayElements = [];
    if (this.pauseOverlayBackground) { this.pauseOverlayBackground.destroy(); this.pauseOverlayBackground = null; }
    if (this.pauseDecisionHandler) { this.input.keyboard.off("keydown", this.pauseDecisionHandler, this); this.pauseDecisionHandler = null; }
  }

  /* ==== 输入 ==== */
  setupInput() {
    this.keys = this.input.keyboard.addKeys({
      up: Phaser.Input.Keyboard.KeyCodes.W,
      down: Phaser.Input.Keyboard.KeyCodes.S,
      left: Phaser.Input.Keyboard.KeyCodes.A,
      right: Phaser.Input.Keyboard.KeyCodes.D,
      focus: Phaser.Input.Keyboard.KeyCodes.SHIFT,
    });

    this.movementDirectionOrder = this.movementDirectionOrder ?? [];
    this.movementKeyHandlers = [];
    MOVEMENT_KEY_BINDINGS.forEach(({ code, direction }) => {
      const downEvent = `keydown-${code}`;
      const upEvent = `keyup-${code}`;
      const downHandler = (event) => { if (event?.repeat) return; this.registerMovementDirection(direction); };
      const upHandler = () => { this.unregisterMovementDirection(direction); };
      this.input.keyboard.on(downEvent, downHandler, this);
      this.input.keyboard.on(upEvent, upHandler, this);
      this.movementKeyHandlers.push({ event: downEvent, handler: downHandler }, { event: upEvent, handler: upHandler });
    });

    this.input.on("wheel", this.handleMouseWheel, this);
    this.input.keyboard.on("keydown", this.handlePauseKey, this);

    const offAll = () => {
      this.input.off("wheel", this.handleMouseWheel, this);
      this.input.keyboard.off("keydown", this.handlePauseKey, this);
      if (this.movementKeyHandlers) {
        this.movementKeyHandlers.forEach(({ event, handler }) => this.input.keyboard.off(event, handler, this));
        this.movementKeyHandlers = [];
      }
      this.movementDirectionOrder = [];
      this.clearPauseOverlay();
    };
    this.events.once("shutdown", offAll);
    this.events.once("destroy", offAll);
  }

  /* ==== 计时器 ==== */
  setupTimers() {
    this.rebuildAttackTimer();
    this.scheduleSpawnTimer();
  }
  scheduleSpawnTimer() {
    if (this.debugBossMode) {
      if (this.spawnTimer) { this.spawnTimer.remove(); this.spawnTimer = null; }
      return;
    }
    if (this.roundComplete || this.roundAwaitingDecision) {
      if (this.spawnTimer) { this.spawnTimer.remove(); this.spawnTimer = null; }
      return;
    }
    if (this.spawnTimer) this.spawnTimer.remove();
    const normalizedRank = Math.max(this.rank, 0.1);
    const intervalSeconds = Math.max(10 / normalizedRank, 0.1);
    const delay = intervalSeconds * 1000;
    this.spawnTimer = this.time.addEvent({ delay, loop: true, callback: () => this.spawnEnemy() });
  }

  /* ==== HUD ==== */
  setupHUD() { this.updateOverlayScale(); this.updateHUD(); }
  update(time, delta) {
    if (this.boss) this.updateBossUI(this.boss);
    if (this.isPaused) return;
    this.elapsed += delta;

    if (this.guinsooStacks > 0 && this.time.now >= (this.guinsooStacksExpireAt || 0)) {
      this.guinsooStacks = 0;
      this.guinsooStacksExpireAt = 0;
      this.guinsooFullProcCounter = 0;
      this.rebuildAttackTimer();
    }

    this.updatePlayerMovement();
    this.updateWeapon(delta);
    this.updateBullets(delta);
    this.updateEnemies();
    this.updateLoot(delta);

    /* ==== 新增：更新 Boss 弹幕与Utsuho AI ==== */
    this.updateBossBullets(delta);
    if (this.boss && this.boss.isBoss && this.boss.bossKind === "Utsuho") {
      this.updateUtsuhoAI(delta);
    }

    this.updateRoundTimer(delta);
    this.checkNoDamageRankBonus();
    this.updateHUD();
  }

  updatePlayerMovement() {
    const { up, down, left, right, focus } = this.keys;
    let vx = 0, vy = 0;

    if (this.playerSpeedBuffExpiresAt && this.time.now >= this.playerSpeedBuffExpiresAt) {
      this.playerSpeedBuffMultiplier = 1;
      this.playerSpeedBuffExpiresAt = 0;
    }

    if (left.isDown) vx -= 1;
    if (right.isDown) vx += 1;
    if (up.isDown) vy -= 1;
    if (down.isDown) vy += 1;

    const inputVX = vx, inputVY = vy;
    const isMoving = inputVX !== 0 || inputVY !== 0;
    let normX = 0, normY = 0;
    if (isMoving) {
      const len = Math.sqrt(inputVX*inputVX + inputVY*inputVY);
      normX = inputVX / len; normY = inputVY / len;
    }

    const speedModifier = focus.isDown ? PLAYER_FOCUS_MULTIPLIER : 1;
    const speedBuffMultiplier = this.playerSpeedBuffMultiplier ?? 1;
    const speed = PLAYER_BASE_SPEED * speedModifier * speedBuffMultiplier;

    if (isMoving) {
      const velX = Phaser.Math.RoundAwayFromZero(normX * speed);
      const velY = Phaser.Math.RoundAwayFromZero(normY * speed);
      this.player.body.setVelocity(velX, velY);
    } else {
      this.player.body.setVelocity(0, 0);
    }

    this.updatePlayerAnimationState(isMoving, inputVX, inputVY);

    this.focusIndicator.setVisible(focus.isDown).setPosition(this.player.x, this.player.y);
    this.setRangeDisplay(focus.isDown);
    if (this.rangeVisible) this.drawRangeCircle(); else this.rangeGraphics.clear();
  }

  drawRangeCircle() {
    if (!this.rangeVisible) { this.rangeGraphics.clear(); return; }
    const originX = this.weaponSprite ? this.weaponSprite.x : this.player.x;
       const originY = this.weaponSprite ? this.weaponSprite.y : this.player.y;
    const radius = statUnitsToPixels(this.playerStats.range);
    this.rangeGraphics.clear();
    this.rangeGraphics.lineStyle(0.6, 0x44aaff, 0.4);
    this.rangeGraphics.strokeCircle(originX, originY, radius);
  }
  setRangeDisplay(isVisible) {
    if (this.rangeVisible === isVisible) return;
    this.rangeVisible = isVisible;
    if (!isVisible) this.rangeGraphics.clear();
  }

  updateWeapon(delta) {
    const angleDelta = Phaser.Math.DegToRad((WEAPON_ORBIT_SPEED * delta) / 1000);
    this.weaponAngle = (this.weaponAngle + angleDelta) % Phaser.Math.PI2;
    const offsetX = Math.cos(this.weaponAngle) * WEAPON_ORBIT_RADIUS;
    const offsetY = Math.sin(this.weaponAngle) * WEAPON_ORBIT_RADIUS;
    this.weaponSprite.setPosition(this.player.x + offsetX, this.player.y + offsetY);
    if (this.rangeVisible) this.drawRangeCircle();
  }

  updateBullets(delta) {
    const bullets = this.bullets.getChildren();
    for (let i=bullets.length-1; i>=0; i-=1) {
      const bullet = bullets[i];
      if (!bullet.active) continue;
      const timeAlive = this.time.now - bullet.spawnTime;
      if (timeAlive > BULLET_LIFETIME) { this.destroyBullet(bullet); continue; }

      const target = this.findNearestEnemy(bullet.x, bullet.y, Number.MAX_VALUE);
      if (target) {
        const angle = Phaser.Math.Angle.Between(bullet.x, bullet.y, target.x, target.y);
        this.physics.velocityFromRotation(angle, BULLET_SPEED, bullet.body.velocity);
        bullet.setRotation(angle + Math.PI / 2);
      } else {
        bullet.body.setVelocity(0, 0);
      }
    }
  }

  updateEnemies() {
    const enemies = this.enemies.getChildren();
    const now = this.time.now;
    for (let i=enemies.length-1; i>=0; i-=1) {
      const enemy = enemies[i];
      if (!enemy.active) continue;
      if (!enemy.state) enemy.state = "idle";

      // Utsuho 的运动完全由专属AI驱动，这里不覆盖
      if (enemy.isBoss && enemy.bossKind === "Utsuho") continue;

      const slowFactor = (enemy.slowUntil && now < enemy.slowUntil) ? (1 - (enemy.slowPct || 0)) : 1;

      const distanceToPlayer = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.player.x, this.player.y);
      if (enemy.state === "idle") {
        if (distanceToPlayer <= 100 && (!enemy.attackCooldownUntil || now >= enemy.attackCooldownUntil)) {
          enemy.state = "charging";
          enemy.attackChargeUntil = now + 500;
          enemy.attackTargetX = this.player.x;
          enemy.attackTargetY = this.player.y;
          enemy.body.setVelocity(0, 0);
          this.playSfx("enemycharge");
        } else {
          const chaseSpeed = 50 * slowFactor;
          this.physics.moveToObject(enemy, this.player, chaseSpeed);
          const blocked = enemy.body.blocked;
          if (blocked.left || blocked.right || blocked.up || blocked.down) {
            const baseAngle = Phaser.Math.Angle.Between(enemy.x, enemy.y, this.player.x, this.player.y);
            const dodgeAngle = baseAngle + Phaser.Math.DegToRad(Phaser.Math.RND.pick([-90, 90]));
            this.physics.velocityFromRotation(dodgeAngle, 50 * slowFactor, enemy.body.velocity);
          }
        }
      } else if (enemy.state === "charging") {
        enemy.body.setVelocity(0, 0);
        if (now >= enemy.attackChargeUntil) {
          const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, enemy.attackTargetX, enemy.attackTargetY);
          this.physics.velocityFromRotation(angle, 200 * slowFactor, enemy.body.velocity);
          enemy.state = "dashing";
          enemy.attackEndTime = now + 350;
        }
      } else if (enemy.state === "dashing") {
        if (now >= enemy.attackEndTime) {
          enemy.body.setVelocity(0, 0);
          enemy.state = "idle";
          enemy.attackCooldownUntil = now + 800;
          enemy.nextWanderChange = now;
        }
      }
    }
  }

  updateLoot(_delta) {
    const lootItems = this.loot.getChildren();
    const attractRadius = 50; // 固定拾取半径
    for (let i=lootItems.length-1; i>=0; i-=1) {
      const item = lootItems[i];
      if (!item.active) continue;
      const distance = Phaser.Math.Distance.Between(item.x, item.y, this.player.x, this.player.y);
      if (distance <= attractRadius) item.magnetActive = true;
      if (item.magnetActive) this.physics.moveToObject(item, this.player, PICKUP_ATTRACT_SPEED);
      else item.body.setVelocity(0, 0);
    }
  }

updateRoundTimer(delta) {
    if (this.roundComplete || this.debugBossMode) return;  // Boss模式直接跳过计时
    this.roundTimeLeft = Math.max(0, this.roundTimeLeft - delta);
    if (this.roundTimeLeft <= 0) this.handleRoundComplete();
}

  checkNoDamageRankBonus() {
    if (this.roundComplete || !this.nextNoDamageRankCheck) return;
    if (this.time.now >= this.nextNoDamageRankCheck) {
      this.rank = Number((this.rank * RANK_NO_DAMAGE_MULTIPLIER).toFixed(2));
      this.scheduleSpawnTimer();
      this.updateHUD();
      this.nextNoDamageRankCheck += NO_DAMAGE_RANK_INTERVAL;
    }
  }

  handleRoundComplete() {
    if (this.roundComplete) return;
    this.roundComplete = true; this.roundAwaitingDecision = true;
    if (this.spawnTimer) { this.spawnTimer.remove(); this.spawnTimer = null; }
    this.clearEnemies();
    this.clearBullets();
    this.showRoundOverlay();
  }
  clearEnemies() { this.enemies.getChildren().forEach((e)=> e.destroy()); }
  clearBullets() { this.bullets.getChildren().forEach((b)=> this.destroyBullet(b)); }

  showRoundOverlay() {
    this.clearRoundOverlay();
    const bg = this.add.rectangle(GAME_WIDTH/2, GAME_HEIGHT/2, GAME_WIDTH, GAME_HEIGHT, 0x000000, 0.6).setScrollFactor(0).setDepth(40);
    const title = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 - 28, "Stage Clear!", {
      fontFamily: '"Zpix", monospace', fontSize: "18px", color: "#ffffff",
    }).setOrigin(0.5).setScrollFactor(0).setDepth(41);
    ensureBaseFontSize(title);
    const prompt = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2 + 16, "Press Y to continue, N to end", {
      fontFamily: '"Zpix", monospace', fontSize: "14px", color: "#d0d0ff",
    }).setOrigin(0.5).setScrollFactor(0).setDepth(41);
    ensureBaseFontSize(prompt);

    this.roundOverlayBackground = bg;
    this.roundOverlayElements = [title, prompt];
    this.updateOverlayScale();

    this.roundDecisionHandler = (e) => {
      if (e.code === "KeyY" || e.code === "Enter") this.continueAfterRound(true);
      else if (e.code === "KeyN" || e.code === "Escape") this.continueAfterRound(false);
    };
    this.input.keyboard.on("keydown", this.roundDecisionHandler, this);
  }
  clearRoundOverlay() {
    if (this.roundOverlayElements?.length) this.roundOverlayElements.forEach((el)=> el.destroy());
    this.roundOverlayElements = [];
    if (this.roundOverlayBackground) { this.roundOverlayBackground.destroy(); this.roundOverlayBackground = null; }
    if (this.roundDecisionHandler) { this.input.keyboard.off("keydown", this.roundDecisionHandler, this); this.roundDecisionHandler = null; }
  }
  continueAfterRound(shouldContinue) {
    this.clearRoundOverlay();
    this.roundAwaitingDecision = false;
    if (shouldContinue) {
      this.rank = Number((this.rank + ROUND_CONTINUE_RANK_BONUS).toFixed(2));
      this.roundComplete = false;
      const now = this.time.now;
      this.lastDamageTimestamp = now;
      this.nextNoDamageRankCheck = now + NO_DAMAGE_RANK_INTERVAL;
      this.roundTimeLeft = ROUND_DURATION;
      this.generateRandomSegmentsMap();
      if (this.player) {
        this.player.setPosition(WORLD_SIZE/2, WORLD_SIZE/2);
        this.player.body.setVelocity(0, 0);
        this.playerFacing = "down";
        this.stopPlayerAnimation(this.playerFacing);
      }
      this.scheduleSpawnTimer();
    } else {
      this.roundComplete = true;
      this.endRunVictory();
    }
    this.updateHUD();
    this.updateOverlayScale();
  }
  endRunVictory() {
    this.physics.pause();
    if (this.spawnTimer) { this.spawnTimer.remove(); this.spawnTimer = null; }
    if (this.attackTimer) { this.attackTimer.remove(); this.attackTimer = null; }
    const text = this.add.text(GAME_WIDTH/2, GAME_HEIGHT/2, "Adventure Complete", {
      fontFamily: '"Zpix", monospace', fontSize: "20px", color: "#66ff99",
      backgroundColor: "#000000aa", padding: { x: 8, y: 6 },
    }).setOrigin(0.5).setScrollFactor(0).setDepth(50);
    ensureBaseFontSize(text);
    setFontSizeByScale(text, CAMERA_ZOOM / this.currentZoom);
  }

  updateHUD() {
      // Boss模式下不显示倒计时
      if (this.debugBossMode) {
          if (this.ui.timerValue) this.ui.timerValue.textContent = "--:--";
      } else {
          const timeLeft = Math.max(0, this.roundTimeLeft);
          const totalSeconds = Math.ceil(timeLeft / 1000);
          const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, "0");
          const seconds = (totalSeconds % 60).toString().padStart(2, "0");
          if (this.ui.timerValue) this.ui.timerValue.textContent = `${minutes}:${seconds}`;
      }
      
      if (this.ui.killValue) this.ui.killValue.textContent = `${this.killCount}`;
      if (this.ui.rankValue) this.ui.rankValue.textContent = this.formatRankValue(this.rank);
      if (this.ui.pointValue) this.ui.pointValue.textContent = `${this.playerPoints}`;
  }

  formatRankValue(value) { return Number.isInteger(value) ? `${value}` : value.toFixed(2); }

  /* ==== 伤害与战斗 ==== */
  showDamageNumber(x, y, amount, type = "physical") {
    const colors = { physical: "#ffd966", magic: "#66aaff", crit: "#ff5c5c", heal: "#66ff66" };
    const displayValue = typeof amount === "number" ? Math.round(amount) : amount;
    const text = this.add.text(x, y, `${displayValue}`, {
      fontFamily: '"Zpix", monospace', fontSize: "14px", color: colors[type] ?? "#ffffff",
    }).setOrigin(0.5).setDepth(80);
    text.setStroke("#000000", 2);
    text.x += Phaser.Math.FloatBetween(-4, 4);
    text.y += Phaser.Math.FloatBetween(-2, 2);
    this.tweens.add({
      targets: text, y: text.y +10, alpha: 0, duration: 650, ease: "Cubic.Out",
      onComplete: () => text.destroy(),
    });
  }
  showHealNumber(x, y, amount) {
    if (amount > 0) this.showDamageNumber(x, y, amount, "heal");
  }

  // AR/DEF减伤：实际伤害 = 原始伤害 * 100/(100+AR) - DEF
  applyMitigationToTarget(amount, targetStatsOrObj) {
    const ar = Math.max(0, Math.round(targetStatsOrObj?.armor ?? targetStatsOrObj?.ar ?? 0));
    const def = Math.max(0, Math.round(targetStatsOrObj?.defense ?? targetStatsOrObj?.def ?? 0));
    const afterAr = amount * (100 / (100 + ar));
    const afterDef = afterAr - def;
    return Math.max(0, Math.round(afterDef));
  }

  // 新增：对自机施加法术伤害（Boss弹幕）
  applyMagicDamageToPlayer(amount) {
    const actual = this.applyMitigationToTarget(Math.round(amount), { armor: this.playerStats.armor ?? 0, def: this.playerStats.defense ?? 0 });
    this.showDamageNumber(this.player.x, this.player.y - 12, actual, "magic");
    this.currentHp = Math.max(this.currentHp - actual, 0);
    this.updateResourceBars();
    const now = this.time.now;
    this.lastDamageTimestamp = now;
    this.nextNoDamageRankCheck = now + NO_DAMAGE_RANK_INTERVAL;
    if (this.currentHp <= 0) this.gameOver();
  }

  // 分离显示：通过时间和位置错开
  displayDamageWithSeparation(x, y, amount, type, orderIndex) {
    const delay = 90 * orderIndex;
    const stepY = 14 * orderIndex;
    const offsetX = (orderIndex % 2 === 0) ? -6 : 6;
    this.time.delayedCall(delay, () => {
      this.showDamageNumber(x + offsetX, y - 12 + stepY, amount, type);
    });
  }

  tryFireBullet() {
    const rangePixels = statUnitsToPixels(this.playerStats.range);
    const originX = this.weaponSprite ? this.weaponSprite.x : this.player.x;
    const originY = this.weaponSprite ? this.weaponSprite.y : this.player.y;
    const target = this.findNearestEnemy(originX, originY, rangePixels);
    if (!target) return;

    const bullet = this.physics.add.sprite(originX, originY, "bullet");
    bullet.setDepth(8); bullet.setScale(0.64);
    bullet.body.setAllowGravity(false);
    bullet.body.setSize(8, 16); bullet.body.setOffset(4, 0);
    bullet.spawnTime = this.time.now;
    bullet.damage = this.playerStats.attackDamage;
    bullet.damageType = "physical";
    bullet.isCrit = false;

    this.bullets.add(bullet);
    this.attachBulletTrailToBullet(bullet);
    this.playSfx("playershoot");

    const angle = Phaser.Math.Angle.Between(bullet.x, bullet.y, target.x, target.y);
    this.physics.velocityFromRotation(angle, BULLET_SPEED, bullet.body.velocity);
    bullet.setRotation(angle + Math.PI / 2);
  }

  findNearestEnemy(x, y, range = Number.MAX_VALUE) {
    const enemies = this.enemies.getChildren();
    let nearest = null;
    const maxRangeSq = (range === Number.MAX_VALUE) ? Number.MAX_VALUE : range * range;
    let nearestDist = maxRangeSq;
    for (let i=0;i<enemies.length;i+=1) {
      const enemy = enemies[i];
      if (!enemy.active) continue;
      const distanceSq = Phaser.Math.Distance.Squared(x, y, enemy.x, enemy.y);
      if (distanceSq <= nearestDist) { nearest = enemy; nearestDist = distanceSq; }
    }
    return nearest;
  }

  spawnEnemy() {
    if (this.debugBossMode) return;
    if (this.roundComplete || this.roundAwaitingDecision || this.enemies.getChildren().length >= ENEMY_MAX_COUNT) return;

    const edge = Phaser.Math.Between(0, 3);
    const margin = TILE_SIZE * 2;
    let x = WORLD_SIZE / 2, y = WORLD_SIZE / 2;
    switch (edge) {
      case 0: x = Phaser.Math.Between(margin, WORLD_SIZE - margin); y = margin; break;
      case 1: x = WORLD_SIZE - margin; y = Phaser.Math.Between(margin, WORLD_SIZE - margin); break;
      case 2: x = Phaser.Math.Between(margin, WORLD_SIZE - margin); y = WORLD_SIZE - margin; break;
      default: x = margin; y = Phaser.Math.Between(margin, WORLD_SIZE - margin); break;
    }

    const enemy = this.enemies.create(x, y, "enemy");
    enemy.setDepth(6);
    enemy.body.setAllowGravity(false);
    enemy.body.setSize(14, 14);
    enemy.body.setOffset(1, 1);
    enemy.maxHp = 500;
    enemy.hp = enemy.maxHp;
    enemy.lastHitAt = 0;
    enemy.state = "idle";
    enemy.wanderAngle = Phaser.Math.FloatBetween(0, Math.PI * 2);
    enemy.nextWanderChange = this.time.now + Phaser.Math.Between(1200, 2200);
    enemy.attackChargeUntil = 0;
    enemy.attackEndTime = 0;
    enemy.attackCooldownUntil = this.time.now + Phaser.Math.Between(600, 1000);
    enemy.attackTargetX = enemy.x;
    enemy.attackTargetY = enemy.y;
    enemy.setRotation(0);
    enemy.isBoss = false;
    enemy.hitComboCount = 0;
    enemy.hitComboExpireAt = 0;
    enemy.slowPct = 0;
    enemy.slowUntil = 0;

    enemy.armor = 0;
    enemy.def = 0;
  }

  handleBulletEnemyOverlap(bullet, enemy) {
    if (!enemy.active) return;

    const now = this.time.now;
    const preHp = enemy.hp;

    const entries = [];
    const baseDamage = Math.max(0, Math.round(bullet.damage));
    entries.push({ type: "physical", amount: baseDamage, source: "basic", isOnHit: false });

    let tripleProc = false;
    if (this.hasItemEquipped(BROKEN_KINGS_BLADE_ID)) {
      const blade = EQUIPMENT_DATA[BROKEN_KINGS_BLADE_ID];
      const eff = blade.effects;

      const rawPercent = preHp * eff.percentCurrentHp;
      let percentDmg = Math.max(eff.percentMinDamage, rawPercent);
      if (enemy.isBoss) {
        percentDmg = Math.min(percentDmg, eff.percentMaxDamageBoss);
      } else {
        percentDmg = Math.min(percentDmg, eff.percentMaxDamageNonBoss);
      }
      entries.push({ type: "physical", amount: Math.round(percentDmg), source: "bork_percent", isOnHit: true });

      if (enemy.hitComboCount >= eff.tripleHitThreshold) {
        entries.push({ type: "magic", amount: Math.round(eff.tripleHitMagicDamage), source: "bork_triple", isOnHit: false });
        enemy.slowPct = Math.max(enemy.slowPct || 0, eff.tripleHitSlowPct);
        enemy.slowUntil = now + eff.tripleHitSlowMs;
        this.playerSpeedBuffMultiplier = Math.max(this.playerSpeedBuffMultiplier || 1, 1 + eff.selfHastePct);
        this.playerSpeedBuffExpiresAt = now + eff.selfHasteMs;
        enemy.hitComboCount = 0;
        enemy.hitComboExpireAt = 0;
        tripleProc = true;
      }
    }

    let witsOnHitDamagePerProc = 0;
    if (this.hasItemEquipped(WITS_END_ID)) {
      const eff = EQUIPMENT_DATA[WITS_END_ID].effects;
      witsOnHitDamagePerProc = Math.round(eff.witsMagicOnHit);
      entries.push({ type: "magic", amount: witsOnHitDamagePerProc, source: "wits", isOnHit: true });
    }

    if (this.hasItemEquipped(NASHORS_TOOTH_ID)) {
      const eff = EQUIPMENT_DATA[NASHORS_TOOTH_ID].effects;
      const bonusAD = Math.max(0, this.playerStats.attackDamage - PLAYER_BASE_STATS.attackDamage);
      const ap = this.playerStats.abilityPower || 0;
      const nashorDmg = Math.round(
        eff.nashorBase + eff.nashorBonusAdRatio * bonusAD + eff.nashorApRatio * ap
      );
      entries.push({ type: "magic", amount: nashorDmg, source: "nashor", isOnHit: true });
    }

    let extraProcMultiplier = 1;
    if (this.hasItemEquipped(GUINSOOS_RAGEBLADE_ID)) {
      const eff = EQUIPMENT_DATA[GUINSOOS_RAGEBLADE_ID].effects;
      entries.push({ type: "magic", amount: Math.round(eff.ragebladeMagicOnHit), source: "guinsoo", isOnHit: true });

      this.guinsooStacks = Math.min((this.guinsooStacks || 0) + 1, eff.ragebladeMaxStacks || 4);
      this.guinsooStacksExpireAt = now + (eff.ragebladeStackDurationMs || 5000);

      if (this.guinsooStacks >= (eff.ragebladeMaxStacks || 4)) {
        this.guinsooFullProcCounter = (this.guinsooFullProcCounter || 0) + 1;
        if (this.guinsooFullProcCounter % (eff.ragebladeExtraProcEvery || 3) === 0) {
          extraProcMultiplier = 1 + (eff.ragebladeExtraProcsAtFull || 2);
        }
      } else {
        this.guinsooFullProcCounter = 0;
      }

      this.rebuildAttackTimer();
    }

    const damageGroups = {
      basic: { physical: 0, magic: 0 },
      onHit: { physical: 0, magic: 0 }
    };

    for (const e of entries) {
      const times = e.isOnHit ? extraProcMultiplier : 1;
      for (let k = 0; k < times; k += 1) {
        const after = this.applyMitigationToTarget(e.amount, enemy);
        if (after <= 0) continue;

        const group = e.isOnHit ? damageGroups.onHit : damageGroups.basic;
        group[e.type] += after;

        if (e.source === "wits") {
          const hpPct = this.currentHp / this.playerStats.maxHp;
          if (hpPct < (EQUIPMENT_DATA[WITS_END_ID].effects.witsHealThresholdHpPct || 0.5)) {
            this.currentHp = Math.min(this.currentHp + after, this.playerStats.maxHp);
            this.showHealNumber(this.player.x, this.player.y - 28, after);
            this.updateResourceBars();
          }
        }
      }
    }

    let displayOrder = 0;
    if (damageGroups.basic.physical > 0) {
      this.displayDamageWithSeparation(enemy.x, enemy.y, damageGroups.basic.physical, "physical", displayOrder++);
    }
    if (damageGroups.basic.magic > 0) {
      this.displayDamageWithSeparation(enemy.x, enemy.y, damageGroups.basic.magic, "magic", displayOrder++);
    }
    if (damageGroups.onHit.physical > 0) {
      this.displayDamageWithSeparation(enemy.x, enemy.y, damageGroups.onHit.physical, "physical", displayOrder++);
    }
    if (damageGroups.onHit.magic > 0) {
      this.displayDamageWithSeparation(enemy.x, enemy.y, damageGroups.onHit.magic, "magic", displayOrder++);
    }

    const totalDamage =
      damageGroups.basic.physical + damageGroups.basic.magic +
      damageGroups.onHit.physical + damageGroups.onHit.magic;
    enemy.hp -= totalDamage;

    if (enemy.isBoss) this.updateBossUI(enemy);

    if (enemy.hp <= 0) {
      this.killEnemy(enemy);
    }

    const ls = this.playerEquipmentStats.physicalLifeSteal ?? 0;
    if (ls > 0) {
      const physicalTotal = damageGroups.basic.physical + damageGroups.onHit.physical;
      if (physicalTotal > 0) {
        const heal = Math.max(0, Math.round(physicalTotal * ls));
        if (heal > 0) {
          this.currentHp = Math.min(this.currentHp + heal, this.playerStats.maxHp);
          this.showHealNumber(this.player.x, this.player.y - 14, heal);
          this.updateResourceBars();
        }
      }
    }

    this.destroyBullet(bullet);
  }

  hasItemEquipped(itemId) {
    return this.playerEquipmentSlots.some((id) => id === itemId);
  }

  handleBrokenKingsBladeOnHit(_context) { return null; }

  handlePlayerEnemyContact(_player, enemy) {
    const now = this.time.now;
    if (!enemy.lastDamageTick || now - enemy.lastDamageTick >= 650) {
      /* 修改：Boss 接触伤害按Boss配置，否则用默认常量，不改变原有逻辑 */
      const dmg = (enemy.isBoss && enemy.contactDamage) ? enemy.contactDamage : ENEMY_CONTACT_DAMAGE;
      this.applyDamageToPlayer(dmg);
      enemy.lastDamageTick = now;
    }
  }

  applyDamageToPlayer(amount) {
    const actual = this.applyMitigationToTarget(Math.round(amount), this.playerStats);
    this.showDamageNumber(this.player.x, this.player.y - 12, actual, "physical");
    this.currentHp = Math.max(this.currentHp - actual, 0);
    this.updateResourceBars();
    const now = this.time.now;
    this.lastDamageTimestamp = now;
    this.nextNoDamageRankCheck = now + NO_DAMAGE_RANK_INTERVAL;
    if (this.currentHp <= 0) this.gameOver();
  }

  killEnemy(enemy) {
    this.playSfx("enemyexploded");
    // 修改：Utsuho死亡贴图
    if (enemy.isBoss && enemy.bossKind === "Utsuho") {
      enemy.setTexture(BOSS_UTSUHO_CONFIG.textureDeath);
    } else {
      enemy.setTexture("enemyDeath");
    }
    enemy.setVelocity(0, 0);
    enemy.active = false;
    enemy.body.enable = false;
    this.killCount += 1;
    this.updateHUD();

    // Boss死亡收尾
    if (enemy.isBoss) {
      this.clearBossUI();
      if (this.bossMusic) { this.bossMusic.stop(); this.bossMusic.destroy(); this.bossMusic = null; }
      this.boss = null;
      this.bossKind = null;
      // 清空所有Boss弹幕
      this.clearBossBullets();
    }

    this.time.delayedCall(260, () => enemy.destroy());
    this.maybeDropPoint(enemy.x, enemy.y);
  }

  maybeDropPoint(x, y) {
    if (Phaser.Math.FloatBetween(0, 1) > 0.3) return;
    const drops = Phaser.Math.Between(0, 30);
    for (let i=0;i<drops;i+=1) {
      const angle = Phaser.Math.FloatBetween(0, Math.PI * 2);
      const distance = Phaser.Math.FloatBetween(6, 22);
      const dropX = x + Math.cos(angle) * distance;
      const dropY = y + Math.sin(angle) * distance;
      const point = this.loot.create(dropX, dropY, "point");
      point.setDepth(5);
      point.body.setAllowGravity(false);
      point.body.setDrag(600, 600);
      point.magnetActive = false;
      point.amount = 1;
    }
  }

  collectPoint(_player, point) {
    if (!point.active) return;
    this.playSfx("itempick");
    this.loot.remove(point, true, true);
    this.playerPoints += point.amount;
    const manaGain = point.amount * 10;
    this.currentMana = Math.min(this.currentMana + manaGain, PLAYER_MANA_MAX);
    this.updateResourceBars();
    this.updateHUD();
  }

  destroyBullet(bullet) {
    if (!bullet || bullet.destroyed) return;
    this.detachBulletTrailFromBullet(bullet, true);
    bullet.destroyed = true;
    this.bullets.remove(bullet, true, true);
  }

  /* ==== 新增：Boss 弹幕销毁与更新 ==== */
  destroyBossBullet(b) {
    if (!b || b.destroyed) return;
    if (b.trailTimer) { b.trailTimer.remove(false); b.trailTimer = null; }
    b.destroyed = true;
    this.bossBullets.remove(b, true, true);
  }
  clearBossBullets() {
    if (!this.bossBullets) return;
    this.bossBullets.getChildren().forEach((b) => this.destroyBossBullet(b));
  }
// 在 updateBossBullets 方法中添加核弹轨迹生成逻辑
  updateBossBullets(delta) {
      if (!this.bossBullets) return;
      const dt = delta / 1000;
      const list = this.bossBullets.getChildren();
      for (let i = list.length - 1; i >= 0; i -= 1) {
          const b = list[i];
          if (!b.active) continue;

          // 前向速度 + 加速度
          b.forwardSpeed = (b.forwardSpeed || 0) + (b.accel || 0) * dt;

          // 速度分解：方向向量（ux,uy）与其法向（-uy,ux）
          const ux = b.ux || 1;
          const uy = b.uy || 0;
          const side = b.sideSpeed || 0;
          const fs = b.forwardSpeed || 0;

          const vx = ux * fs + (-uy) * side;
          const vy = uy * fs + (ux) * side;
          b.body.setVelocity(vx, vy);

          // 新增：核弹轨迹生成
          if (b.texture.key === "u_bullet_nuclearbomb") {
              if (!b.lastSpawnPos) {
                  b.lastSpawnPos = { x: b.x, y: b.y };
              }
              const step = this.tilesToPx(4); // 每4格检查一次
              const dist = Phaser.Math.Distance.Between(b.x, b.y, b.lastSpawnPos.x, b.lastSpawnPos.y);
              if (dist >= step) {
                  // 生成 nuclearspawn
                  const s = this.add.image(b.x, b.y, "u_bullet_nuclearspawn").setDepth(b.depth - 1);
                  this.setDisplaySizeByTiles(s, BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearspawn.size);
                  s.setRotation(Math.atan2(uy, ux));
                  s.setAlpha(1);

                  // 1秒后淡出并生成 hazard
                  this.time.delayedCall(5000, () => {
                      this.tweens.add({
                          targets: s,
                          alpha: 0,
                          duration: 400,
                          onComplete: () => {
                              // 生成10个 nuclearhazard
                              for (let i = 0; i < 1; i++) {
                                  const offR = this.tilesToPx(2);
                                  const rx = Phaser.Math.FloatBetween(-offR, offR);
                                  const ry = Phaser.Math.FloatBetween(-offR, offR);
                                  const hx = s.x + rx;
                                  const hy = s.y + ry;
                                  this.spawnBossBullet({
                                      key: "u_bullet_nuclearhazard",
                                      sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearhazard.size,
                                      judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearhazard.judge,
                                      from: { x: hx, y: hy },
                                      dirAngleDeg: Phaser.Math.Between(0, 359),
                                      forwardSpeed: 1,
                                      accel: 0,
                                      sideSpeed: 0,
                                  }, BOSS_UTSUHO_CONFIG.bulletMagicDamage, true);
                              }
                              s.destroy();
                          }
                      });
                  });

                  b.lastSpawnPos = { x: b.x, y: b.y };
              }
          }

          // 离开画布则删除（完全移出）
          const r = b.hitRadius || 0;
          if (b.x < -r || b.x > WORLD_SIZE + r || b.y < -r || b.y > WORLD_SIZE + r) {
              this.destroyBossBullet(b);
          }
      }
  }

  gameOver() {
    this.playSfx("pldead");
    this.physics.pause();
    this.time.removeAllEvents();
    const text = this.add.text(this.player.x, this.player.y - 12, "GAME OVER", {
      fontFamily: '"Zpix", monospace', fontSize: "18px", color: "#ff3344",
      backgroundColor: "#000000aa", padding: { x: 6, y: 4 },
    }).setOrigin(0.5).setScrollFactor(0);
    ensureBaseFontSize(text);
    setFontSizeByScale(text, CAMERA_ZOOM / this.currentZoom);
  }

  updateStatPanel() {
    if (!this.ui.statContainer) return;
    const stats = [
      `AD ${this.playerStats.attackDamage}`,
      `AP ${this.playerStats.abilityPower}`,
      `AS ${this.playerStats.attackSpeed.toFixed(2)}/s`,
      `HP ${this.playerStats.maxHp}`,
      `CR ${(this.playerStats.critChance * 100).toFixed(0)}%`,
      `CD ${this.playerStats.critDamage}%`,
      `DEF ${this.playerStats.defense}`,
      `AR ${this.playerStats.armor}`,
      `AH ${this.playerStats.abilityHaste || 0}`,
      `射程 ${this.playerStats.range}`,
    ];
    this.ui.statContainer.innerHTML = "";
    stats.forEach((line) => {
      const span = document.createElement("span");
      span.className = "stat-line";
      span.textContent = line;
      this.ui.statContainer.appendChild(span);
    });
  }

  updateResourceBars() {
    if (this.ui.hpBar) {
      const hpPct = this.currentHp / this.playerStats.maxHp;
      this.ui.hpBar.style.width = `${Phaser.Math.Clamp(hpPct, 0, 1) * 100}%`;
    }
    if (this.ui.hpLabel) this.ui.hpLabel.textContent = `HP ${this.currentHp}/${this.playerStats.maxHp}`;
    if (this.ui.mpBar) {
      const mpPct = this.currentMana / PLAYER_MANA_MAX;
      this.ui.mpBar.style.width = `${Phaser.Math.Clamp(mpPct, 0, 1) * 100}%`;
    }
    if (this.ui.mpLabel) this.ui.mpLabel.textContent = `MP ${this.currentMana}/${PLAYER_MANA_MAX}`;
  }

  /* ==== 装备栏：DOM 辅助 ==== */
  getSlotIndexFromEvent(event) {
    const el = event?.currentTarget ?? event?.target;
    if (!el) return null;
    const slotEl = el.closest?.(".equipment-slot[data-slot-index]") || el;
    const idx = Number(slotEl?.dataset?.slotIndex);
    return Number.isFinite(idx) ? idx : null;
  }

  /* ==== 装备栏：拖拽实现 ==== */
  handleEquipmentDragStart(event) {
    const sourceIndex = this.getSlotIndexFromEvent(event);
    if (sourceIndex == null) return;
    if (!this.playerEquipmentSlots[sourceIndex]) return;

    this.draggedEquipmentSlot = sourceIndex;

    if (event.dataTransfer) {
      try {
        event.dataTransfer.setData("text/plain", String(sourceIndex));
        event.dataTransfer.effectAllowed = "move";
      } catch (_) {}
    }

    const el = event.currentTarget;
    el.classList.add("dragging");
    event.stopPropagation?.();
  }

  handleEquipmentDragEnter(event) {
    const targetIndex = this.getSlotIndexFromEvent(event);
    if (targetIndex == null) return;
    event.preventDefault?.();
    const el = event.currentTarget;
    el.classList.add("drag-over");
  }

  handleEquipmentDragOver(event) {
    event.preventDefault?.();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
  }

  handleEquipmentDragLeave(event) {
    const el = event.currentTarget;
    el.classList.remove("drag-over");
  }

  handleEquipmentDrop(event) {
    event.preventDefault?.();
    event.stopPropagation?.();

    const sourceIndex =
      this.draggedEquipmentSlot != null
        ? this.draggedEquipmentSlot
        : Number(event.dataTransfer?.getData("text/plain"));

    const targetIndex = this.getSlotIndexFromEvent(event);

    const el = event.currentTarget;
    el.classList.remove("drag-over");

    if (
      sourceIndex == null ||
      targetIndex == null ||
      sourceIndex === targetIndex
    ) {
      return;
    }

    this.swapEquipmentSlots(sourceIndex, targetIndex);

    if (this.activeEquipmentTooltipIndex === sourceIndex) {
      this.activeEquipmentTooltipIndex = targetIndex;
    } else if (this.activeEquipmentTooltipIndex === targetIndex) {
      this.activeEquipmentTooltipIndex = sourceIndex;
    }
    this.refreshEquipmentTooltip(this.activeEquipmentTooltipIndex);
  }

  handleEquipmentDragEnd(event) {
    if (this.equipmentUi?.slots?.length) {
      this.equipmentUi.slots.forEach(({ element }) => {
        element.classList.remove("dragging");
        element.classList.remove("drag-over");
      });
    }
    this.draggedEquipmentSlot = null;
    event.stopPropagation?.();
  }

  /* ==== 装备栏：悬停提示 ==== */
  handleEquipmentSlotEnter(event) {
    const idx = this.getSlotIndexFromEvent(event);
    if (idx == null) return;
    this.activeEquipmentTooltipIndex = idx;
    this.refreshEquipmentTooltip(idx);
  }

  handleEquipmentSlotLeave() {
    this.activeEquipmentTooltipIndex = null;
    this.refreshEquipmentTooltip(null);
  }

  positionPreviewUnderSlot1() {
    const ui = this.equipmentUi;
    if (!ui || !ui.previewElement || !ui.previewImage || !ui.slots?.[0]) return;

    const slotEl = ui.slots[0].element;
    const rect = slotEl.getBoundingClientRect();
    const previewEl = ui.previewElement;

    previewEl.style.position = "fixed";
    previewEl.style.left = `${Math.round(rect.left)}px`;
    previewEl.style.top = `${Math.round(rect.bottom + 4)}px`;
    previewEl.style.width = `${Math.round(rect.width)}px`;
    previewEl.style.height = `${Math.round(rect.height)}px`;
    previewEl.style.zIndex = "1000";
    previewEl.style.pointerEvents = "none";

    previewEl.style.background = "transparent";
    previewEl.style.backgroundImage = "none";

    ui.previewImage.style.width = "100%";
    ui.previewImage.style.height = "100%";
  }

  bindPreviewRepositionEvents() {
    this.previewRepositionHandler = () => this.positionPreviewUnderSlot1();
    window.addEventListener("resize", this.previewRepositionHandler);
    window.addEventListener("scroll", this.previewRepositionHandler, true);
  }

  unbindPreviewRepositionEvents() {
    if (this.previewRepositionHandler) {
      window.removeEventListener("resize", this.previewRepositionHandler);
      window.removeEventListener("scroll", this.previewRepositionHandler, true);
      this.previewRepositionHandler = null;
    }
  }

  /* ==== Boss 相关：生成与UI ==== */
  spawnBoss(cfg) {
    const boss = this.enemies.create(WORLD_SIZE / 2, WORLD_SIZE / 2, cfg.textureKey);
    boss.setDepth(9);
    boss.body.setAllowGravity(false);

    const frame = boss.frame;
    const fw = frame?.width ?? boss.width ?? TILE_SIZE;
    const fh = frame?.height ?? boss.height ?? TILE_SIZE;
    const maxDim = Math.max(fw, fh);
    const target = TILE_SIZE * (cfg.tiles || 4);
    const scale = target / Math.max(1, maxDim);
    boss.setScale(scale);
    boss.body.setSize(Math.max(8, fw * scale * 0.9), Math.max(8, fh * scale * 0.9), true);

    boss.isBoss = true;
    boss.maxHp = cfg.maxHp;
    boss.hp = cfg.maxHp;
    boss.armor = cfg.armor;
    boss.def = 0;
    boss.state = "idle";
    boss.attackCooldownUntil = this.time.now + 1000;

    this.boss = boss;
  }

  /* ==== 新增：通用 Boss 生成（通过ID） ==== */
  spawnBossById(id, positionOpt) {
    const cfg = BOSS_REGISTRY[id];
    if (!cfg) return;

    if (id === "Utsuho") {
      // 位置：默认中上方，可覆写
      const px = positionOpt?.x ?? (WORLD_SIZE / 2);
      const py = positionOpt?.y ?? Math.floor(WORLD_SIZE * 0.25);

      const boss = this.enemies.create(px, py, BOSS_UTSUHO_CONFIG.textureIdle);
      boss.setDepth(9);
      boss.body.setAllowGravity(false);
      boss.setCollideWorldBounds(true);

      // 缩放到4格
      const frame = boss.frame;
      const fw = frame?.width ?? boss.width ?? TILE_SIZE;
      const fh = frame?.height ?? boss.height ?? TILE_SIZE;
      const maxDim = Math.max(fw, fh);
      const target = TILE_SIZE * (BOSS_UTSUHO_CONFIG.tiles || 4);
      const scale = target / Math.max(1, maxDim);
      boss.setScale(scale);
      boss.body.setSize(Math.max(8, fw * scale * 0.9), Math.max(8, fh * scale * 0.9), true);

      // 标记
      boss.isBoss = true;
      boss.bossKind = "Utsuho";
      boss.maxHp = BOSS_UTSUHO_CONFIG.maxHp;
      boss.hp = BOSS_UTSUHO_CONFIG.maxHp;
      boss.armor = BOSS_UTSUHO_CONFIG.armor;
      boss.def = 0;
      boss.contactDamage = BOSS_UTSUHO_CONFIG.contactDamage;
      boss.state = "idle";
      boss.setDataEnabled();

      // Utsuho AI 初始化
      this.initUtsuhoAI(boss);

      this.boss = boss;
      this.bossKind = "Utsuho";
      this.createBossUI(BOSS_UTSUHO_CONFIG.name, BOSS_UTSUHO_CONFIG.title);
      // 新增：显示固定标题
      this.showBossHeader(BOSS_UTSUHO_CONFIG.name, BOSS_UTSUHO_CONFIG.title);

      return;
    }

    // 其他Boss（如Dummy）仍可调用
    this.spawnBoss(cfg);
    this.createBossUI(cfg.name, cfg.title);
  }

  createBossUI(name, title) {
    this.clearBossUI();

    const barW = 80;           // 头顶条宽
    const barH = 8;            // 头顶条高
    const pad  = 1;

    // 容器：世界坐标（不设置 setScrollFactor(0)）
    const container = this.add.container(0, 0).setDepth((this.boss?.depth || 9) + 1);

    // 背板
    const bg = this.add.rectangle(0, 0, barW, barH, 0x000000, 0.6).setOrigin(0.5);
    // 血量填充
    const fill = this.add.rectangle(-barW/2 + pad, 0, barW - pad*2, barH - pad*2, 0xff3333, 1)
      .setOrigin(0, 0.5);

    // 名字（可选）
    const nameText = this.add.text(0, -barH - 10, name || "", {
      fontFamily: '"Zpix", monospace',
      fontSize: "10px",
      color: "#ffffff",
      align: "center",
    }).setOrigin(0.5);

    container.add([bg, fill, nameText]);

    this.bossUi = {
      container,
      fill,
      barW,
      barH,
      nameText,
    };

    // 初始画一次
    this.updateBossUI(this.boss);
  }


  drawBossBar(ratio) {
    const { gfx, barX, barY, barW, barH } = this.bossUi;
    if (!gfx) return;
    const clamped = Phaser.Math.Clamp(ratio, 0, 1);

    gfx.clear();
    gfx.lineStyle(2, 0x000000, 1);
    gfx.strokeRect(barX - barW / 2, barY - barH / 2, barW, barH);

    const innerX = barX - barW / 2 + 1;
    const innerY = barY - barH / 2 + 1;
    const innerW = Math.max(0, Math.floor((barW - 2) * clamped));
    const innerH = barH - 2;

    gfx.fillStyle(0xff3333, 1);
    gfx.fillRect(innerX, innerY, innerW, innerH);
  }

  updateBossUI(target) {
    if (!target || !target.isBoss || !this.bossUi?.container) return;
    const ratio = Phaser.Math.Clamp(target.hp / Math.max(1, target.maxHp), 0, 1);

    // 位置：在 Boss 头顶（displayHeight 的一部分再加点偏移）
    const offset = (target.displayHeight || 32) * 0.6 + 12;
    this.bossUi.container.setPosition(target.x, target.y - offset);

    // 宽度：根据血量比例更新
    const innerW = (this.bossUi.barW - 2) * ratio;
    this.bossUi.fill.displayWidth = Math.max(0, innerW);
  }


  clearBossUI() {
    if (this.bossUi?.gfx) { this.bossUi.gfx.destroy(); this.bossUi.gfx = null; }
    if (this.bossUi?.nameText) { this.bossUi.nameText.destroy(); this.bossUi.nameText = null; }
    if (this.bossUi?.titleText) { this.bossUi.titleText.destroy(); this.bossUi.titleText = null; }
    if (this.bossUi?.container) { this.bossUi.container.destroy(); this.bossUi.container = null; }
    this.clearBossHeader();
    }

  /* ==== Utsuho 专属：工具函数 ==== */
  tilesToPx(tiles) { return tiles * TILE_SIZE; }
  setSpriteCircleHit(b, judgeTiles) {
    const r = Math.max(0, (judgeTiles || 0) * TILE_SIZE / 2);
    b.hitRadius = r;
    const fw = b.width || TILE_SIZE, fh = b.height || TILE_SIZE;
    const offX = fw/2 - r, offY = fh/2 - r;
    if (r > 0) b.body.setCircle(r, offX, offY);
    else b.body.setSize(fw, fh);
  }
  setDisplaySizeByTiles(sprite, sizeTiles) {
    const px = this.tilesToPx(sizeTiles || 1);
    sprite.setDisplaySize(px, px);
  }
  aimUnit(fromX, fromY, toX, toY) {
    const dx = toX - fromX, dy = toY - fromY;
    const len = Math.hypot(dx, dy) || 1;
    return { ux: dx/len, uy: dy/len, angle: Math.atan2(dy, dx) };
  }

  /* ==== Utsuho：初始化AI与状态机 ==== */
  initUtsuhoAI(boss) {
    const now = this.time.now;
    boss.ai = {
      mode: 1,
      modeEndsAt: now + BOSS_UTSUHO_CONFIG.modeDurations.m1,
      state: "seek", // seek | charge | dash1 | dash2 | m2_charge | m2_fire | m3_charge | m3_fire | m4_charge | m4_dash
      // 通用
      nextThink: 0,
      // Mode1 / Mode4 冲刺
      chargeEndsAt: 0,
      dashTarget: null,
      dashSpeed: 0,
      dashDir: { ux: 1, uy: 0 },
      dashLastMarkPos: { x: boss.x, y: boss.y },
      // Mode2
      m2_loopUntil: 0,
      m2_nextRingAt: 0,
      m2_phaseDegFixed: Phaser.Math.Between(0, 359),
      m2_ringEndsAt: 0, // 本次五秒窗口结束
      // Mode3
      m3_loopUntil: 0,
      m3_nextNukeAt: 0,
      m3_nextBlueAt: 0,
      m3_phaseNuke: 0,
      m3_phaseBlue: Phaser.Math.Between(0, 359),
    };
    boss.body.setVelocity(0, 0);
  }

  /* ==== Utsuho：AI 更新 ==== */
  updateUtsuhoAI(delta) {
    const boss = this.boss;
    if (!boss || !boss.active) return;
    const ai = boss.ai;
    const now = this.time.now;

    // 模式切换
    if (now >= ai.modeEndsAt) {
      this.advanceUtsuhoMode();
      return;
    }

    // 根据模式分派
    switch (ai.mode) {
      case 1: this.updateUtsuhoMode1(delta); break;
      case 2: this.updateUtsuhoMode2(delta); break;
      case 3: this.updateUtsuhoMode3(delta); break;
      case 4: this.updateUtsuhoMode4(delta); break;
      default: this.updateUtsuhoMode1(delta); break;
    }
  }

  advanceUtsuhoMode() {
    const boss = this.boss;
    if (!boss || !boss.active) return;
    const ai = boss.ai;
    const now = this.time.now;

    // 清除所有Boss弹幕
    this.clearBossBullets();
    boss.body.setVelocity(0, 0);

    if (ai.mode === 1) {
      ai.mode = 2;
      ai.modeEndsAt = now + BOSS_UTSUHO_CONFIG.modeDurations.m2;
      ai.state = "m2_charge";
      ai.m2_loopUntil = ai.modeEndsAt;
      ai.m2_phaseDegFixed = Phaser.Math.Between(0, 359);
      ai.m2_ringEndsAt = 0;
      this.startWarningCharge(3 * 1000); // 3秒蓄力
      return;
    }
    if (ai.mode === 2) {
      ai.mode = 3;
      ai.modeEndsAt = now + BOSS_UTSUHO_CONFIG.modeDurations.m3;
      ai.state = "m3_charge";
      ai.m3_loopUntil = ai.modeEndsAt;
      ai.m3_phaseNuke = 0;
      ai.m3_phaseBlue = Phaser.Math.Between(0, 359);
      this.startWarningCharge(3 * 1000);
      return;
    }
    if (ai.mode === 3) {
      ai.mode = 4;
      ai.modeEndsAt = now + BOSS_UTSUHO_CONFIG.modeDurations.m4;
      ai.state = "m4_charge";
      this.startCharge(1 * 1000); // Mode4 开场1s蓄力
      return;
    }
    if (ai.mode === 4) {
      ai.mode = 1;
      ai.modeEndsAt = now + BOSS_UTSUHO_CONFIG.modeDurations.m1;
      ai.state = "seek";
      return;
    }
  }

  /* ==== Utsuho：通用贴图朝向 ==== */
  setUtsuhoMoveTextureByVel() {
    const boss = this.boss;
    if (!boss) return;
    const vx = boss.body.velocity.x;
    const vy = boss.body.velocity.y;
    const spd = Math.hypot(vx, vy);
    if (spd < 1) {
      boss.setTexture(BOSS_UTSUHO_CONFIG.textureIdle);
      boss.setFlipX(false);
      return;
    }
    // 简单规则：纵向为主 -> movedown；否则 moveright/flipX
    if (Math.abs(vy) >= Math.abs(vx)) {
      boss.setTexture(BOSS_UTSUHO_CONFIG.textureMoveDown);
      boss.setFlipX(false);
    } else {
      boss.setTexture(BOSS_UTSUHO_CONFIG.textureMoveRight);
      boss.setFlipX(vx < 0);
    }
  }

  /* ==== Utsuho：蓄力提示（Mode2/3用的核警示框） ==== */
  startWarningCharge(ms) {
    const boss = this.boss;
    const ai = boss.ai;
    ai.stateChargeUntil = this.time.now + ms;
    ai.state = ai.mode === 2 ? "m2_charge" : "m3_charge";
    this.playSfx("enemycharge");
    // 提示框（在Boss下方，不遮挡Boss）
    if (boss.warningSprite) { boss.warningSprite.destroy(); boss.warningSprite = null; }
    const warn = this.add.image(boss.x, boss.y, "utsuho_warning").setDepth(boss.depth - 1);
    this.setDisplaySizeByTiles(warn, BOSS_UTSUHO_CONFIG.hitboxes.warningSize);
    warn.setAlpha(0.9);
    boss.warningSprite = warn;
  }
  startCharge(ms) {
    const boss = this.boss;
    const ai = boss.ai;
    ai.stateChargeUntil = this.time.now + ms;
    this.playSfx("enemycharge");
  }

  /* ==== Utsuho：Mode1（40秒）==== */
  updateUtsuhoMode1(delta) {
    const boss = this.boss;
    const ai = boss.ai;
    const now = this.time.now;

    const dist = Phaser.Math.Distance.Between(boss.x, boss.y, this.player.x, this.player.y);

    if (ai.state === "seek") {
      // 半径100外：向自机移动
      if (dist > 100) {
        this.physics.moveToObject(boss, this.player, BOSS_UTSUHO_CONFIG.moveSpeed);
        this.setUtsuhoMoveTextureByVel();
        return;
      }
      // 半径300内：开始蓄力 -> 冲刺1
      this.startCharge(3000);
      boss.body.setVelocity(0, 0);
      ai.chargeEndsAt = now + 1000;
      ai.dashTarget = { x: this.player.x, y: this.player.y }; // 记录当前自机坐标
      ai.state = "charge";

      this.playSfx("enemycharge");
      return;
    }

    if (ai.state === "charge") {
      boss.body.setVelocity(0, 0);
      if (now >= ai.chargeEndsAt) {
        // 冲刺到墙或边界
        const dir = this.aimUnit(boss.x, boss.y, ai.dashTarget.x, ai.dashTarget.y);
        ai.dashDir = { ux: dir.ux, uy: dir.uy };
        ai.dashSpeed = BOSS_UTSUHO_CONFIG.dashInitSpeed;
        ai.state = "dash1";
        ai.dashLastMarkPos = { x: boss.x, y: boss.y };
      }
      return;
    }

    if (ai.state === "dash1" || ai.state === "dash2") {
      // 冲刺速度累增
      ai.dashSpeed += BOSS_UTSUHO_CONFIG.dashAccel * (delta/1000);
      boss.body.setVelocity(ai.dashDir.ux * ai.dashSpeed, ai.dashDir.uy * ai.dashSpeed);
      this.setUtsuhoMoveTextureByVel();
      // 每4格投放 nuclearspawn
      this.tryPlaceNuclearSpawnAlongDash(ai);
      // 碰到边缘或墙体？
      const blocked = boss.body.blocked;
      const hitEdge = blocked.left || blocked.right || blocked.up || blocked.down;
      if (ai.state === "dash1" && hitEdge) {
        boss.body.setVelocity(0, 0);
        // 记录当前自机坐标，冲刺到该点
        const t = { x: this.player.x, y: this.player.y };
        const dir2 = this.aimUnit(boss.x, boss.y, t.x, t.y);
        ai.dashDir = { ux: dir2.ux, uy: dir2.uy };
        ai.dashTarget = t;
        ai.dashSpeed = BOSS_UTSUHO_CONFIG.dashInitSpeed;
        ai.state = "dash2";
        ai.dashLastMarkPos = { x: boss.x, y: boss.y };
        return;
      }
      if (ai.state === "dash2") {
          const d2 = Phaser.Math.Distance.Between(boss.x, boss.y, ai.dashTarget.x, ai.dashTarget.y);
          // 新增：检测是否碰到边界
          const blocked = boss.body.blocked;
          const hitEdge = blocked.left || blocked.right || blocked.up || blocked.down;
          // 到达目标点 或 撞墙 都结束冲刺
          if (d2 <= 10 || hitEdge) {
              boss.body.setVelocity(0, 0);
              ai.state = "seek";
          }
      }
      return;
    }
  }

  tryPlaceNuclearSpawnAlongDash(ai) {
      const boss = this.boss;
      const last = ai.dashLastMarkPos || { x: boss.x, y: boss.y };
      const step = this.tilesToPx(4); // 每4格
      const dist = Phaser.Math.Distance.Between(boss.x, boss.y, last.x, last.y);
      if (dist < step) return;

      // 生成 nuclearspawn 贴图（方向与冲刺方向一致）
      const s = this.add.image(boss.x, boss.y, "u_bullet_nuclearspawn").setDepth(boss.depth - 1);
      this.setDisplaySizeByTiles(s, BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearspawn.size);
      s.setRotation(Math.atan2(ai.dashDir.uy, ai.dashDir.ux));
      s.setAlpha(1);

      // 1秒后淡出，并在当前位置生成20个核危害粒子
      this.time.delayedCall(1000, () => {
          this.tweens.add({
              targets: s, 
              alpha: 0, 
              duration: 400, 
              onComplete: () => {
                  // 生成20个 nuclearhazard：速度10，方向随机，带粒子特效
                  const count = 20;
                  const spawnX = s.x;  // 使用消失时的位置
                  const spawnY = s.y;
                  for (let i = 0; i < count; i += 1) {
                      const offR = this.tilesToPx(2); // 四格内：±2格随机
                      const rx = Phaser.Math.FloatBetween(-offR, offR);
                      const ry = Phaser.Math.FloatBetween(-offR, offR);
                      const bx = spawnX + rx;
                      const by = spawnY + ry;
                      this.spawnBossBullet({
                          key: "u_bullet_nuclearhazard",
                          sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearhazard.size,
                          judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearhazard.judge,
                          from: { x: bx, y: by },
                          dirAngleDeg: Phaser.Math.Between(0, 359),
                          forwardSpeed: 10,
                          accel: 0,
                          sideSpeed: 0,
                      }, BOSS_UTSUHO_CONFIG.bulletMagicDamage, true);
                  }
                  s.destroy();
              }
          });
      });

      ai.dashLastMarkPos = { x: boss.x, y: boss.y };
      // 冲刺粒子
      this.emitDashParticles(boss.x, boss.y);
  }

  emitDashParticles(x, y) {
    const p = this.add.image(x, y, "dash_particle").setDepth(7).setAlpha(0.9);
    this.tweens.add({ targets: p, alpha: 0, scale: 0.2, duration: 240, onComplete: () => p.destroy() });
  }

  /* ==== Utsuho：Mode2（35秒）==== */
  updateUtsuhoMode2(_delta) {
    const boss = this.boss; const ai = boss.ai; const now = this.time.now;
    // 移动至地图中心
    if (ai.state === "m2_charge") {
      if (boss.warningSprite) {
        boss.warningSprite.setPosition(boss.x, boss.y);
      }
      // 保证先居中
      const centerX = WORLD_SIZE/2, centerY = WORLD_SIZE/2;
      const d = Phaser.Math.Distance.Between(boss.x, boss.y, centerX, centerY);
      if (d > 6) {
        this.physics.moveTo(boss, centerX, centerY, BOSS_UTSUHO_CONFIG.moveSpeed);
        this.setUtsuhoMoveTextureByVel();
      } else {
        boss.body.setVelocity(0,0);
      }
      // 等待3秒蓄力结束
      if (now >= ai.stateChargeUntil) {
        // 开火5秒：yellow 环状弹幕
        if (boss.warningSprite) { boss.warningSprite.destroy(); boss.warningSprite = null; }
        ai.state = "m2_fire";
        ai.m2_phaseDegFixed = Phaser.Math.Between(0, 359); // 本轮固定相位
        ai.m2_ringEndsAt = now + 5000; // 持续5秒
        ai.m2_nextRingAt = now; // 立刻开第一轮
      }
      return;
    }

    if (ai.state === "m2_fire") {
      boss.body.setVelocity(0, 0);
      // 发射窗内：每0.01s 放一圈 60 发
      if (now <= ai.m2_ringEndsAt) {
        if (now >= ai.m2_nextRingAt) {
          this.fireRing({
            key: "u_bullet_yellow",
            sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.yellow.size,
            judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.yellow.judge,
            count: 60,
            phaseDeg: ai.m2_phaseDegFixed,
            forwardSpeed: 100,
            accel: 666,
            sideSpeed: 0,
          }, BOSS_UTSUHO_CONFIG.bulletMagicDamage);
          ai.m2_nextRingAt = now + 200; 
        }
      } else {
        // 重回3秒蓄力，直到模式时间到
        if (now + 3000 <= ai.m2_loopUntil) {
          ai.state = "m2_charge";
          this.startWarningCharge(3000);
        } else {
          // 模式即将结束：等待advanceUtsuhoMode切换
          boss.body.setVelocity(0, 0);
        }
      }
      return;
    }
  }

  /* ==== Utsuho：Mode3（70秒）==== */
  updateUtsuhoMode3(_delta) {
    const boss = this.boss; const ai = boss.ai; const now = this.time.now;
    if (ai.state === "m3_charge") {
      if (boss.warningSprite) boss.warningSprite.setPosition(boss.x, boss.y);
      // 居中
      const centerX = WORLD_SIZE/2, centerY = WORLD_SIZE/2;
      const d = Phaser.Math.Distance.Between(boss.x, boss.y, centerX, centerY);
      if (d > 6) {
        this.physics.moveTo(boss, centerX, centerY, BOSS_UTSUHO_CONFIG.moveSpeed);
        this.setUtsuhoMoveTextureByVel();
      } else { boss.body.setVelocity(0,0); }
      if (now >= ai.stateChargeUntil) {
        if (boss.warningSprite) { boss.warningSprite.destroy(); boss.warningSprite = null; }
        ai.state = "m3_fire";
        ai.m3_nextNukeAt = now;     // 3秒间隔核弹，立即第一轮
        ai.m3_nextBlueAt = now;     // 0.2秒间隔蓝弹
        ai.m3_phaseNuke = 0;
        // ai.m3_phaseBlue 保持并在每次生成内随机增量
      }
      return;
    }

  // 在 updateUtsuhoMode3 函数中修改:
  if (ai.state === "m3_fire") {
      boss.body.setVelocity(0, 0);
      if (now >= ai.m3_nextNukeAt) {
          // 修改：保证8个核弹均匀分布在360度上
          this.fireRing({
              key: "u_bullet_nuclearbomb",
              sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearbomb.size,
              judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearbomb.judge,
              count: 8,
              phaseDeg: ai.m3_phaseNuke,
              forwardSpeed: 20,
              accel: 10,
              // 每个核弹的侧向速度仍然保持交替
              sideSpeed:0,
          }, BOSS_UTSUHO_CONFIG.bulletMagicDamage);
          
          // 每次旋转45度(360/8)，保证下一轮的核弹与这一轮错开
          ai.m3_phaseNuke = (ai.m3_phaseNuke + 22.5) % 360;
          ai.m3_nextNukeAt = now + 6000;
      }
      // 0.2秒一次：蓝弹环（3个），初始相位每次 += 随机(-10,+30)
      if (now >= ai.m3_nextBlueAt) {
        // 本次增量
        ai.m3_phaseBlue = (ai.m3_phaseBlue + Phaser.Math.Between(-0.5, 5)) % 360;
        this.fireRing({
          key: "u_bullet_blue",
          sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.blue.size,
          judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.blue.judge,
          count: 3,
          phaseDeg: ai.m3_phaseBlue,
          forwardSpeed: Phaser.Math.FloatBetween(10, 15),
          accel: 0,
          sideSpeed: 30,
        }, BOSS_UTSUHO_CONFIG.bulletMagicDamage);
        ai.m3_nextBlueAt = now + 200;
      }
      return;
    }
  }

  /* ==== Utsuho：Mode4（35秒）==== */
  updateUtsuhoMode4(delta) {
    const boss = this.boss; const ai = boss.ai; const now = this.time.now;

    if (ai.state === "m4_charge") {
      boss.body.setVelocity(0, 0);
      if (now >= ai.stateChargeUntil) {
        this.startCharge(3000); 
        // 冲刺到墙 -> 冲刺到记录点；与Mode1相同，但spawn淡出后额外放 bigyellow 环（持续1秒内，每0.2秒发2发，方向朝向自机）
        ai.dashTarget = { x: this.player.x, y: this.player.y };
        const dir = this.aimUnit(boss.x, boss.y, ai.dashTarget.x, ai.dashTarget.y);
        ai.dashDir = { ux: dir.ux, uy: dir.uy };
        ai.dashSpeed = BOSS_UTSUHO_CONFIG.dashInitSpeed;
        ai.state = "m4_dash1";
        ai.dashLastMarkPos = { x: boss.x, y: boss.y };

      }
      return;
    }

    if (ai.state === "m4_dash1" || ai.state === "m4_dash2") {
      ai.dashSpeed += BOSS_UTSUHO_CONFIG.dashAccel * (delta/1000);
      boss.body.setVelocity(ai.dashDir.ux * ai.dashSpeed, ai.dashDir.uy * ai.dashSpeed);
      this.setUtsuhoMoveTextureByVel();
      // 放置 spawn，并在其淡出时触发 bigyellow 短时环（1秒，0.2s间隔）
      this.tryPlaceNuclearSpawnAlongDash_Mode4(ai);
      // 碰边或达点
      const blocked = boss.body.blocked;
      const hitEdge = blocked.left || blocked.right || blocked.up || blocked.down;
      if (ai.state === "m4_dash1" && hitEdge) {
        boss.body.setVelocity(0, 0);
        const t = { x: this.player.x, y: this.player.y };
        const dir2 = this.aimUnit(boss.x, boss.y, t.x, t.y);
        ai.dashDir = { ux: dir2.ux, uy: dir2.uy };
        ai.dashTarget = t;
        ai.dashSpeed = BOSS_UTSUHO_CONFIG.dashInitSpeed;
        ai.state = "m4_dash2";
        ai.dashLastMarkPos = { x: boss.x, y: boss.y };
        return;
      }
        if (ai.state === "m4_dash2") {
            const d2 = Phaser.Math.Distance.Between(boss.x, boss.y, ai.dashTarget.x, ai.dashTarget.y);
            const blocked = boss.body.blocked;
            const hitEdge = blocked.left || blocked.right || blocked.up || blocked.down;
            if (d2 <= 10 || hitEdge) {
                boss.body.setVelocity(0, 0);
                // 关键修改：直接开始新的充能
                this.startCharge(1000);
                ai.state = "m4_charge";
            }
        }
      return;
    }

    // seek 与 Mode1 相同
    this.updateUtsuhoMode1(delta);
  }

  tryPlaceNuclearSpawnAlongDash_Mode4(ai) {
    const boss = this.boss;
    const last = ai.dashLastMarkPos || { x: boss.x, y: boss.y };
    const step = this.tilesToPx(4); // 每4格
    const dist = Phaser.Math.Distance.Between(boss.x, boss.y, last.x, last.y);
    if (dist < step) return;

    const s = this.add.image(boss.x, boss.y, "u_bullet_nuclearspawn").setDepth(boss.depth - 1);
    this.setDisplaySizeByTiles(s, BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearspawn.size);
    s.setRotation(Math.atan2(ai.dashDir.uy, ai.dashDir.ux));
    s.setAlpha(1);

    // 1秒后淡出 + 生成 bigyellow 环（持续1秒；每0.2秒发一圈；相位=朝向自机角度；一圈2发）
    this.time.delayedCall(1000, () => {
      this.tweens.add({
        targets: s, alpha: 0, duration: 400, onComplete: () => s.destroy(),
      });
      const center = { x: s.x, y: s.y };
      const aim = this.aimUnit(center.x, center.y, this.player.x, this.player.y);
      const phase = Phaser.Math.RadToDeg(aim.angle);
      const endAt = this.time.now + 1000;
      const doRing = () => {
        if (this.time.now > endAt) return;
        this.fireRingAt(center.x, center.y, {
          key: "u_bullet_bigyellow",
          sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.bigyellow.size,
          judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.bigyellow.judge,
          count: 2,
          phaseDeg: phase,
          forwardSpeed: 100,
          accel: 100,
          sideSpeed: 0,
        }, BOSS_UTSUHO_CONFIG.bulletMagicDamage);
        this.time.delayedCall(200, doRing);
      };
      doRing();
      // 顺便生成 hazard 微粒（5个，速度100）
      const count = 2;
      for (let i = 0; i < count; i += 1) {
        const offR = this.tilesToPx(2);
        const rx = Phaser.Math.FloatBetween(-offR, offR);
        const ry = Phaser.Math.FloatBetween(-offR, offR);
        const bx = center.x + rx;
        const by = center.y + ry;
        this.spawnBossBullet({
          key: "u_bullet_nuclearhazard",
          sizeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearhazard.size,
          judgeTiles: BOSS_UTSUHO_CONFIG.hitboxes.bullets.nuclearhazard.judge,
          from: { x: bx, y: by },
          dirAngleDeg: Phaser.Math.Between(0, 359),
          forwardSpeed: 50,
          accel: 0,
          sideSpeed: 0,
        }, BOSS_UTSUHO_CONFIG.bulletMagicDamage, true);
      }
    });

    ai.dashLastMarkPos = { x: boss.x, y: boss.y };
    this.emitDashParticles(boss.x, boss.y);
  }

  /* ==== Utsuho：发弹工具 ==== */
  // 在Boss当前位置发环
  fireRing(params, magicDamage) {
    const boss = this.boss;
    this.fireRingAt(boss.x, boss.y, params, magicDamage);
  }
  // 在指定坐标发环；sideSpeed 可为常数或函数(angleDeg)->值
  fireRingAt(cx, cy, params, magicDamage) {
    const { key, sizeTiles, judgeTiles, count, phaseDeg, forwardSpeed, accel, sideSpeed } = params;
    for (let i = 0; i < count; i += 1) {
      const angDeg = (phaseDeg + i * (360 / count)) % 360;
      const side = (typeof sideSpeed === "function") ? sideSpeed(angDeg) : (sideSpeed || 0);
      this.spawnBossBullet({
        key,
        sizeTiles,
        judgeTiles,
        from: { x: cx, y: cy },
        dirAngleDeg: angDeg,
        forwardSpeed,
        accel,
        sideSpeed: side,
      }, magicDamage, true);
    }
  }
  spawnBossBullet(opts, magicDamage, withTrail = false) {
    const { key, sizeTiles, judgeTiles, from, dirAngleDeg, forwardSpeed, accel, sideSpeed } = opts;
    const b = this.physics.add.image(from.x, from.y, key).setDepth(8);
    b.setActive(true).setVisible(true);
    b.body.setAllowGravity(false);
    this.setDisplaySizeByTiles(b, sizeTiles);
    this.setSpriteCircleHit(b, judgeTiles);
    const rad = Phaser.Math.DegToRad(dirAngleDeg);
    b.ux = Math.cos(rad);
    b.uy = Math.sin(rad);
    b.forwardSpeed = forwardSpeed || 0;
    b.accel = accel || 0;
    b.sideSpeed = sideSpeed || 0;
    b.magicDamage = magicDamage || 0;
    this.bossBullets.add(b);
    if (withTrail) {
      // 复用玩家子弹轨迹作为特效
      b.trailTimer = this.time.addEvent({ delay: 60, loop: true, callback: () => {
        if (!b.active) return;
        const t = this.add.image(b.x, b.y, "bullet_trail").setDepth(7).setBlendMode(Phaser.BlendModes.ADD);
        t.setScale(Phaser.Math.FloatBetween(0.2, 0.4)); t.setAlpha(0.6);
        this.tweens.add({ targets: t, alpha: 0, scale: 0, duration: 220, onComplete: () => t.destroy() });
      }});
    }
    return b;
  }

}

/* ==== Phaser 配置 ==== */
const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  parent: "game",
  pixelArt: true,
  physics: {
    default: "arcade",
    arcade: { gravity: { y: 0 }, debug: false },
  },
  scene: [PreloadScene, StartScene, GameScene],
};

window.addEventListener("load", () => {
  new Phaser.Game(config); // eslint-disable-line no-new
});
